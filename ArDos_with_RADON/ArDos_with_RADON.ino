/*Arduino IDE 1.8.12
  Версия программы RADON v3.0.4 low_pwr 30.09.20 специально для проекта ArDos
  Страница проекта ArDos http://arduino.ru/forum/proekty/delaem-dozimetr
  Желательна установка лёгкого ядра https://alexgyver.github.io/package_GyverCore_index.json и загрузчика OptiBoot v8 https://github.com/Optiboot/optiboot


  1.6.1 01.04.20 - переезд ячеек памяти, если вы устанавливаете прошивку не в первый раз от обязательно делайте сброс!
  1.6.1 20.04.20 - мелкие исправления.
  1.6.1 30.04.20 - мелкие исправления, добавлено сохранение единиц измерения(мкР/мкЗ) в память.
  1.6.1 03.05.20 - мелкие исправления, измененная анимация запуска.
  1.6.2 04.05.20 - добавлено выключение устройства при низком заряде батареи.
  1.6.2 17.05.20 - мелкие исправления, добавлено вибрация при тревоге и индикация попадания частиц,
                 также теперь порог срабатывания тревоги можно настроить в массиве(over_rad_2[]) и выбирать пресеты из настроек у-ва,
                 изменена картинка заряда акб и переработан алгоритм для корректного отбражения при зарядке.
  1.6.3 19.05.20 - мелкие исправления, оптимизация объема скетча, добавлена индикация вибрации,
                 настройки перенесены для удобства в отдельный файл "SETUP", вся графика теперь в отдельном файле,
                 библиотеку "LCD5110_SSVS" необходимо обновить на новую из архива, без нее работа будет некорректна!!!
  1.6.3 22.05.20 - выход из быстрого меню теперь только по удержанию клавиши "вверх".
  1.6.4 23.05.20 - мелкие исправления, добавлена возможность отключать вспышки полностью или только во сне(в настройках пункт "вспышки"),
                 удален пункт меню "подсветка", подсветку теперь можно вкл/выкл только из быстрого меню(текущее состояние сохраняется в память как и раньше),
                 добавлен отдельный файл конфигурации прошивки "config", теперь можно подстроить некоторые аспекты прошивки под свои нужды,
                 добавлена возможность выбора выхода из сна по нажатию на любую клавишу, параметр в "SETUP" - "TYPE_SLEEP_OUT",
                 добавлена возможность выбора типа индикации при тревоге, параметр в "SETUP" - "TYPE_ALARM_IND",
                 добавлена возможность выбора типа выхода из быстрого меню, параметр в "SETUP" - "TYPE_FAST_MENU",
                 если у вас есть сохранненый файл с настройками, его необходимо обновить на новый!
  1.6.4 24.05.20 - добавлен альтернативный главный экран, параметр в "SETUP" - "TYPE_MAIN_SCREEN",
                 добавлено усреднение показаний фона, параметр в "config" - "mid_rad_time",
                 добавлен выбор отображения дополнительного значения в режиме "ФОН" классического дизайна, параметр в "SETUP" - "TYPE_RAD_UNIT"
                 добавлена возможность выбора символа заполнителя для показаний на главных экранах ФОН/ДОЗА/ПОИСК,
                 параметр в "config" - "TYPE_CHAR_FILL", для корректной работы прошивки необходимо обновить библиотеку "LCD5110_SSVS"!
  1.6.5 25.05.20 - мелкие исправления, пункт меню "сброс настроек" удален, сбросить настройки можно все также при вкл. у-ва.,
                 изменены пункты "TYPE_RAD_UNIT" и "mid_rad_time", тепрь они используются для настройке в самом устройстве и хранятся в памяти,
                 добавлена возможность выбора из меню доп.единиц, добавлена возможность выбора в прошивке ед. в режиме поиск, параметр в "SETUP" - "TYPE_SERCH_UNIT".
  1.6.5 26.05.20 - улучшен алгоритм усреднения текущего фона, теперь до первого полноценного усреднения, фон усредняется посекундно, после полноценного усреднения,
                 усреднение идет только по установленному времени и с добавлением в расчет старого усреднения, ед.измерения выбираются теперь в настройках,
                 отображние доп.едениц на экране "ФОН" теперь выбирается в быстром меню,
                 теперь при выборе доп.строки средн. отображается полоса готовности следующего замера(только альтернативный дизайн),
                 перстроен алгоритм графика, тепрь минимальное время обновления составляет 17.5ms(1s - 1000ms).
  1.6.5 27.05.20 - альтернативный дизайн пересмотрен, новый тул бар, одновременное указание сред и макс дозы, график теперь на строчку больше,
                 скорость графика теперь указывается в мс, заряд акб теперь указывается не только графически, но и в процентах левее от указателя,
                 добавлена возможность выключения у-ва из быстрого меню.
  1.6.5 28.05.20 - графические изменения, скорость накачки убрана из статистики, добавлено прямое/обратное движение графика, параметр в "SETUP" - "TYPE_GRAF_MOVE",
                 добавлена индикация имп/с шкалой, предел выбирается в "config" - "GRAF_IND_MAX", добавлены тайм-ауты при бездействии в "настройки"/"статистика"/"быстрое меню",
                 параметр в "config" - "TIME_OUT_SETTINGS"/"TIME_OUT_STATISTIC"/"TIME_OUT_FAST".
  1.6.5 29.05.20 - добавлена графическая индикация накопления дозы до сохранения её в память(если нету времени ждать, можно сохранить выключив у-во из быстрого меню),
                 добавлено автоматическое отключение тревоги при падении фона ниже порога, параметр в "SETUP" - "ALARM_AUTO_DISABLE",
                 также можно настроить гистерезис автоматического отключения, параметр в "config" - "ALARM_AUTO_GISTERESIS".
  1.6.5 30.05.20 - мелкие исправления, добавлено значение "ADC" для акб в отладку, добавлен набор пресетов для автоматического сохранения дозы,
                 добавлен порог не включения у-ва после разряда акб, параметр в "config" - "LOW_BAT_POWER", будет отображена разряженная батарея, затем у-во выключится,
                 добавлен файл "connection" со всеми пинами подключения периферии к мк, файл "image" переименован в "resources",
                 добавлена возможность выбрать действие кнопки "вниз" на экране "поиск", параметр в "SETUP" - "TYPE_SERCH_MOVE",
                 добавлена возможность выбрать действие кнопки "вниз" на экране "доза", параметр в "SETUP" - "TYPE_DOSE_MOVE",
                 добавлена возможность автоматического отключения подсветки без ухода в сон.
  1.7.0 31.05.20 - переработан алгоритм ухода в сон, отладка и ошибки системы питания удалены из-за соображений экономии памяти.
  1.7.0 14.06.20 - добавлен экспериментальный счет времени.
  1.7.0 20.06.20 - интегрирована работа с утилитой по настройке преобразователя, защиту от ненастроенного преобразователя можно отключить в "SETUP" параметр "PUMP_SET_IGNOR".
  1.7.0 22.06.20 - добавлена асинхронная обработка данных, обновленны действия клавиш на главных экранах, добавлены секунды в текущее время дозы,
                 статистику, отладку и ошибки теперь можно включить параметр в "SETUP" - "STATISTIC_RETURN"/"DEBUG_ON_RETURN"/"ERRORS_RETURN"/"PWR_ON_RETURN" (требуется optiboot v8),
                 убраны интервалы сохранения дозы, настроить время сохранения дозы можно в "config" параметр "STAT_UPD_TIME", добавлен экран "ЗАМЕР"
                 для замера излучения "бетта", настроить пресеты замера можно в "SETUP" параметр "diff_measuring[]", переработана статистика,
                 теперь общую дозу можно увидеть и сбросить только на экране "ДОЗА", добавлено предупреждение при сбросе текущей/общей дозы,
                 также теперь можно в ручную откалибровать таймер, параметр в "config" - "TIME_CORRECT".
  1.7.0 23.06.20 - мелкие исправления, полностью выпилен классический дизайн.
  1.7.0 24.06.20 - мелкие исправления, по умолчанию отключена возможность включения устройства по удержанию клавиши "ок", переработан дизайн "замер", теперь он называется "бета",
                 добавлена возможность запрещать сон во время замера в режиме "БЕТА", параметр в "SETUP" - "TYPE_MEASUR_SLEEP", доработан алгоритм генерации звуков, теперь звук можно настраивать с любой частотой и длительностью.
  1.7.1 25.06.20 - полностью удалены библиотеки обработки кнопок и WDT, код из библиотеки WDT перенесен в скетч, обработка кнопок написана с нуля, настроить кнопки можно в "config" - "BTN_GIST_TICK" и "BTN_HOLD_TICK",
                 управление тайм-аутом подсветки передано пункту "ПОДСВЕТКА".
  1.7.1 26.06.20 - мелкие исправления, изменены действия клавиш на главных экранах, замер "бета" перенесен с главных экранов в быстрое меню.
  2.0.0 28.06.20 - мелкие исправления, добавлены 2 порога по превышению фона и 2 порога по превышению дозы(при привышении первых порогов - звуковая индикаци, переход на экран откуда тревога и мигающая надпись"опасночть!" вместо прогресс бара,
                 при привышении вторых порогов всплывающее окно с сигналом тревоги и вибрацией), добавлен тайм-аут в окно сохранения настроек, теперь при бездействии в настройках
                 вы попадаете на экран сохранения настроек, по бездействию на экране сохранения происходит автоматический сброс до предыдущих настроек и выход, библиотека дисплея интегрирована в скетч.
  2.0.0 29.06.20 - мелкие исправления, оптимизация.
  2.0.0 30.06.20 - "статистика" переименована в "параметры".
  2.0.0 05.07.20 - реализован новый алгоритм счета фона, шкала на экране фон теперь показывает точность измерения фона, средний и максимальный фон начинают отображаться только после минимального набора точности,
                   добавлена авария при отсутствии импульсов от счетчика, настроить интервал проверки можно в "config" параметр "IMP_ERROR_TIME", добавлена возможно вывода коэффициента на экран для отладки, параметр в "config" - "COEF_DEBUG",
                   добавлен новый подпункт "ФОН1" в пункт настроек "Щелчки", он позволяет включать треск щелчков по превышению порога "Ф1",
                   добавлен предел отключения режима сна устройства при больших уровнях фона для более корректной работы устройства, параметр в "config" - "RAD_PWR_MANAGER".
  2.0.1 06.07.20 - добавлен глубокий сон при ЕРФ для снижения энергопотребления, минимальный порог отключения можно задать в "config" параметр "RAD_PWR_DOWN", исправлен алгоритм счета фона, оптимизация объема программы.
  2.0.1 16.07.20 - разрешено считывание параметров преобразователя из памяти, если до этого сохраняли их утилитой, добавлена возможность инверсии подсветки дисплея параметр в "SETUP" - "LIGHT_INV".
  2.0.1 19.07.20 - оптимизация объема скетча и скорости работы, стандартные классы "void (setup)" и "void (loop)" больше не используются, добавлена возможность отключить режим "ПОИСК" параметр "SETUP" - "SEARCH_RETURN".
  2.0.1 24.07.20 - мелкие исправления, добавлен тайм-аут диалога сброса текущей/общей дозы.
  2.0.2 13.09.20 - переработан стиль перемещения по меню настроек, новый алгоритм меню настроек занимает меньше памяти.
  3.0.0 14.09.20 - новый алгоритм обработки графика, занимает меньше памяти, расчет данных вынесен за пределы прерывания, должно позволить считать фон более точно и без ограничений.
  3.0.0 15.09.20 - новый алгоритм обработки экранов "ФОН" и "ДОЗА", теперь градации переключения единиц более правильные.
  3.0.0 16.09.20 - мелкие исправления и доработки.
  3.0.0 17.09.20 - добавлен учет мертвого времени счетчика, параметр в "config" - "DEAD_TIME" и "COUNT_RATE".
  3.0.1 18.09.20 - добавлена возможность выбора количества счетчиков подключенных параллельно, параметр в "SETUP" - "GEIGER_COUNT", теперь при выключении режима "ПОИСК" график начинает отображаться в режиме "ФОН",
                   переключиться между графиком и показаниями максимального и среднего фона можно по нажатию на кнопку "ОК", также теперь максимальный фон отображается постоянно, вне зависимости от заполненности буфера счета,
                   так-же график в режиме "ПОИСК" теперь стал авто-масштабируемый, настроить коэффициент масштаба можно в "config" - "GRAF_COEF_MAX", щелчки пищалкой  и световая индикация теперь обрабатываются вне прерывания счетчика.
  3.0.1 20.09.20 - мелкие исправления и доработки.
  3.0.2 21.09.20 - коэффициенты перенесены в Flash память, теперь используются стандартные функции для работы с EEPROM, это позволит сэкономить память, с этой версии больше не нужны никакие сторонние библиотеки.
  3.0.2 22.09.20 - мелкие исправления и доработки.
  3.0.2 23.09.20 - исправлена фатальная ошибка - неверно указанный пин детектора частиц.
  3.0.2 24.09.20 - переработан алгоритм обработки экранов "ФОН" и "ДОЗА", это позволило уменьшить объём программы на 2Кб и расширить функционал добавлением градаций в режим замера и тревогу.
  3.0.2 25.09.20 - оптимизация работы с дисплеем, исправлен автоматический масштаб графиков.
  3.0.3 26.09.20 - новый алгоритм обработки ошибок.
  3.0.3 28.09.20 - шкала точности фона разделена на заполнение времени счета и заполнения всего буфера для быстрого усреднения, добавлен порог выхода из сна при высоких уровнях фона, параметр в "config" - "RAD_SLEEP_OUT",
                   теперь если пункт меню "СОН" стоит "ВЫКЛ", то энергосбережение выключается.
  3.0.3 29.09.20 - новый алгоритм обработки тревоги фона/дозы, добавлено синхронное управление вибрацией и отключением звука 1-х уровней тревоги, тревога по дозе теперь будет срабатывать каждый раз когда установленный порог будет превышен от текущей дозы,
                   добавлена защита от "спантанных" скачков, тревога по фону начинает работать только если набран минимальный массив или превышен порог фона "RAD_PRE_WARN".
  3.0.4 29.09.20 - новый алгоритм обработки мелодий, позволяет более гибко настраивать мелодии пользователю и занимает на 1Кб памяти меньше.

  Внимание!!! При выключении пункта "СОН" в меню настроек влечет увеличением энергопотребления, но тем самым увеличивается производительность устройства.

  Для сброса настроек необходимо зажать клавишу "ОК" и включить питание, появится сообщение об успешном сбросе.
  Если что-то идет или работает не так, в первую очередь пробуйте сброс настроек хот-кеем как описано выше!!!

  Не забудьте установить свои настройки ADC_value и k_delitel в файле SETUP, если вы не настраивали параметры утилитой ранее!!! Этот файл также можно сохранить отдельно и вставлять в новые версии программы.

  После выключения устройства при низком напряжении акб, включить его можно или передергиванием выключателя питания или зажать кнопку "OK" более чем на 2 сек.


  -Обозначения иконок-

  - Иконка "Динамик"
  Две скобки - звки клавиш и треск включен
  Горизонтальная волна - звук клвиш выключен, треск включен
  Звёздочка - звук клавиш включен, треск выключен
  Крестик - звук клавиш и треск выключены

  - Иконка "Колокольчик"
  Волна и две скобки - звки и вибрация при тревоге включены
  Две волны - звук тревоги выключен, вибрация включена
  Звёздочка - ожидание понижения фона
  Крестик - звки и вибрация при тревоге выключены


  -Действия клавиш-

  - На экране ФОН
  Вверх - следующий экран, удерж. - быстрое меню
  Вниз - предыдущий экран, удерж. - сброс показаний среднего и максимального фона(сбросить текущий фон и график/средн. и макс.)
  Ок - сбросить текущий фон(выбор - график или средн. и макс. фон), удерж. - настройки

  - На экране ДОЗА
  Вверх - следующий экран, удерж. - быстрое меню
  Вниз - предыдущий экран, удерж. - сброс показаний текущей дозы / дозы за все время
  Ок - смена подрежима(текущая доза / доза за все время), удерж. - настройки

  - На экране ПОИСК
  Вверх - следующий экран, удерж. - быстрое меню
  Вниз - предыдущий экран, удерж. - сброс графика и показателей
  Ок - пауза графика и показателей, удерж. - настройки

  - На экране БЕТА
  Вверх - остановить замер, удерж. - нет действия
  Вниз - остановить замер, удерж. - принудительный сброс при замере
  Ок - начать замер / следующий замер, удерж. - выход

  - На экране НАСТРОЙКИ
  Вверх - позиция выше/прибавить показания, удерж. - отладка(если выбрано настройками)
  Вниз - позиция ниже/убавить показания, удерж. - параметры(если выбрано настройками)
  Ок - перейти к настройкам/перйти к выбору позиции, удерж. - выход из настроек

  - На экране БЫСТРОЕ МЕНЮ
  Вверх - режим замера бета, удерж. - выход
  Вниз - подсветка экрана вкл/выкл, удерж. - нет действия
  Ок - фонарик вкл/выкл, удерж. - нет действия

  - На экранах ПАРАМЕТРЫ
  Вверх - нет действия, удерж. - нет действия
  Вниз - нет действия, удерж. - нет действия
  Ок - выход из статистики, удерж. - нет действия

  - На экране ОТЛАДКА
  Вверх - прибавить показания, удерж. - нет действия
  Вниз - убавить показания, удерж. - нет действия
  Ок - выбор позиции, удерж. - выход из debug menu

  - На экране ОШИБКА
  Вверх - выход, удерж. - выход
  Вниз - выход, удерж. - выход
  Ок - выход, удерж. - выход


  -Ошибки-

  - Сбой работы таймера
  Видимо что-то пошло не так и таймер не смог откалиброваться, зачастую проблема в напряжении питания и его источнике, попробуйте перезапустить от лбп с напряжением 5в.

  - Перегрузка преобразователя
  Преобразователь напряжения перегружен либо не правильно настроен, проверьте цепи преобразователя и установленные параметры ADC_value / k_delitel / puls.

  - Короткое замыкание преобразователя
  Короткое замыкание преобразователя напряжения либо не правильно настроен, проверьте цепи преобразователя и установленные параметры ADC_value / k_delitel / puls.

  - Нет счета
  Отсутствуют импульсы от счетчика, проверьте цепи подключения счетчика, сам счетчик или преобразователь.
*/

//----------------Библиотеки----------------
#include <Arduino.h>
#include <avr/eeprom.h>
#include <avr/sleep.h>
#include <avr/power.h>
#include <avr/delay.h>

//---------------Конфигурации---------------
#include "LCD.h"
#include "SETUP.h"
#include "config.h"
#include "connection.h"
#include "resources.c"
#include "DefaultFonts.c"

//-------------Для разработчиков-------------
#define ALARM_AUTO_GISTERESIS  (1.00 - (ALARM_AUTO_GIST / 100.00)) //инвертируем проценты

#define GRAF_MAX (GRAF_MAX_MS / (wdt_period / 100.0)) //максимальное время обновления графика
#define GRAF_MIN (GRAF_MIN_MS / (wdt_period / 100.0)) //минимальное время обновления графика

#define MASS_TIME_FACT (MASS_TIME - 1) //фактический номер элемента массивов секунд
#define MASS_BACK_FACT (MASS_BACK - 1) //фактический номер элемента массивов фона
#define GEIGER_CYCLE (pgm_read_byte(&time_mass[0][0]) + pgm_read_byte(&time_mass[0][1])) //минимум секунд для начала расчетов
#define GEIGER_MASS (pgm_read_byte(&time_mass[MASS_TIME_FACT][0]) + pgm_read_byte(&time_mass[MASS_TIME_FACT][1])) //максимум секунд для окончания смещения коэффициентов

#define MAX_GEIGER_TIME (BUFF_LENGTHY - 1) //максимальное время счета
#define MIN_GEIGER_TIME (pgm_read_byte(&time_mass[MASS_TIME_FACT][0]) + pgm_read_byte(&time_mass[MASS_TIME_FACT][1])) //минимальное время счета

#define MAX_SCREENS (SEARCH_RETURN + 1) //максимальное количество главных экранов

volatile uint16_t rad_buff[BUFF_LENGTHY]; //массив секундных замеров для расчета фона
uint16_t graf_buff[76]; //буфер графика
uint16_t rad_scan_buff; //буфер сканирования
uint16_t part_count;   //буфер импульсов
uint32_t rad_mid_buff; //буфер среднего замера

uint16_t wdt_period; //период тика wdt
uint8_t TIME_FACT_1; //секундные интервалы 1
#define TIME_FACT_2  14 //секундные интервалы 2
#define TIME_FACT_3  28 //секундные интервалы 3
#define TIME_FACT_4  29 //секундные интервалы 4
#define TIME_FACT_5  30 //секундные интервалы 5
#define TIME_FACT_6  31 //секундные интервалы 6
#define TIME_FACT_7  32 //секундные интервалы 7
#define TIME_FACT_8  33 //секундные интервалы 8
#define TIME_FACT_9  34 //секундные интервалы 9
#define TIME_FACT_10 35 //секундные интервалы 10
#define TIME_FACT_11 36 //секундные интервалы 11
#define TIME_FACT_12 37 //секундные интервалы 12
#define TIME_FACT_13 38 //секундные интервалы 13
#define TIME_FACT_14 39 //секундные интервалы 14
#define TIME_FACT_15 40 //секундные интервалы 15

uint16_t stat_upd_tmr; //таймер записи статистики в память
uint16_t tmr_mid; //таймер расчета среднего фона
uint16_t tm; //тайм-менеджер графика

uint32_t rad_sum; //сумма импульсов за все время
uint32_t rad_back; //текущий фон
uint32_t rad_dose; //доза
uint32_t rad_mid; //усредненный фон
uint32_t rad_max; //максимальный фон

#if TYPE_SERCH_UNIT
uint16_t rad_imp; //импульсы в секунду
#else
uint16_t rad_imp; //импульсы в секунду
uint32_t rad_scan; //общее кол-во частиц
#endif

#if SEARCH_RETURN
uint16_t maxLevel = 22; //максимальный уровень маштабирования графика
#else
uint16_t maxLevel = 15; //максимальный уровень маштабирования графика
#endif

boolean serch_disable = 0; //флаг запрета движения графика

uint32_t time_save; //время из памяти
uint32_t rad_dose_save; //доза из памяти
uint32_t time_save_old; //предыдущее значение сохраненной времени
uint32_t rad_dose_old; //предыдущее значение дозы

//счетчики времени
uint64_t time_micros = 0; //счетчик реального времени
uint32_t time_sec = 0; //секунды
uint8_t geiger_time_now = 0; //текущий номер набранной секунды счета

uint8_t scr_mode = 0; //текущий режим
uint8_t dose_mode = 0; //режим отображения дозы(текущая/общая)
uint8_t rad_mode = 0; //единицы измерения дозы/фона(мкР/мкЗв)
uint8_t measur = 0; //текущий статус замера

uint8_t bat = 5; //текущий заряд батареи
uint8_t adc_result = MAX_BAT; //результат опроса акб
uint16_t hv_adc; //результат опроса АЦП преобразователя

volatile boolean power_off = 0; //флаг выключения питания
boolean bat_update = 0; //флаг обновления батареи
boolean scr = 0; //флаг обновления экрана
boolean graf = 0; //флаг обновления графика
boolean first_mid = 0; //флаг первого усреднения
boolean knock_disable = 0; //флаг запрет треска кнопками
uint8_t buzz_switch = 0; //указатель на тип треска пищалкой
uint8_t error = 0; //указатель на номер ошибки

uint16_t speed_nak; //скорость накачки
boolean sthv; //флаг считывания скорости накачки

boolean alarm_back_disable = 1; //флаг запрета тревоги фона
boolean alarm_dose_disable = 1; //флаг запрета тревоги дозы
boolean alarm_back_sound_disable = 1; //флаг запрета звука тревоги фона
boolean alarm_dose_sound_disable = 1; //флаг запрета звука тревоги дозы

boolean alarm_back_wait = 0; //флаг ожидания выключения запрета тревоги фона
boolean warn_back_wait = 0; //флаг ожидания выключения запрета предупреждения фона
uint32_t alarm_dose_wait = 0; //флаг ожидания выключения запрета тревоги дозы
uint32_t warn_dose_wait = 0; //флаг ожидания выключения запрета предупреждения дозы

uint16_t warn_level_back = 30; //указатель на уровень тревоги 1 фона в массиве
uint16_t alarm_level_back = 300; //указатель на уровень тревоги 2 фона в массиве
uint16_t warn_level_dose = 10; //указатель на уровень тревоги 1 дозы в массиве
uint16_t alarm_level_dose = 300; //указатель на уровень тревоги 2 дозы в массиве

uint8_t alarm_switch = 0; //указатель текущей тревоги
uint8_t mid_level = 0; //указатель на время замера среднего фона в массиве
uint8_t pos_measur = 0; //указатель на частоту сохранения дозы в массиве
uint8_t rad_flash = 1; //индикация попадания частиц

uint8_t TIME_SLEEP = 10; //время до ухода в сон(должно быть больше чем время подсветки) (10..250)(s)
uint8_t TIME_BRIGHT = 5; //время до отключения подсветки (5..250)(s)
uint8_t sleep_switch = 0; //флаг запрет ухода в сон(0 - сон выкл | 1 - только подсветка | 2 - сон вкл)
boolean sleep = 0; //флаг активного сна
boolean light = 0; //флаг выключенной подсветки

boolean light_lcd = 1; //подсветка дисплея
uint8_t contrast = 70; //контрастность дисплея

volatile uint8_t tick_wdt; //счетчик тиков для обработки данных
uint8_t time_wdt; //счетчик тиков для отсчета секунды
uint8_t cnt_pwr; //счетчик ухода в сон

uint16_t buzz_freq; //рассчитанная частота щелчков
uint16_t buzz_time; //рассчитанное время щелчков

volatile uint8_t btn_tmr; //таймер тиков обработки
boolean btn_check; //флаг разрешения опроса кнопки
boolean btn_state; //флаг текущего состояния кнопки

uint32_t first_froze = 0; //счетчик 1-го замера
uint32_t second_froze = 0; //счетчик 2-го замера
uint16_t time_switch = 0; //счетчик времени замера
boolean alarm_measur = 0; //флаг запрета повторного оповещения
boolean next_measur = 0; //флаг следующего замера

volatile uint16_t cnt_puls; //количество циклов таймера 1 для пищалки
volatile uint16_t TIMER1_PRELOAD; //частота таймера 1 для пищалки
volatile boolean buzz_on; //флаг активности бузера

float now = 0.00; //текущее соотношение ячеек сравнения
#if COEF_DEBUG //отладка коэффициента
float debug_coef = 0.00; //для  вывода общего коэффициента в дебаг
#endif

int atexit(void (* /*func*/ )()) {
  return 0;
}

#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))

//--------------------------------------Инициализация---------------------------------------------------
int main(void)  //инициализация
{
  initTimer(); //инициализация таймера millis();

  CONV_INIT; //инициализация преобразователя
  BUZZ_INIT; //инициализация бузера
  DET_1_INIT; //инициализация детектора частиц
  LIGHT_INIT; //инициализация подсветки
  PWR_LCD_INIT; //инициализация питания дисплея
  RAD_FLASH_INIT; //инициализация фонарика
  FLASH_INIT; //инициализация индикатора частиц
  VIBRO_INIT; //инициализация вибромотора

  LCD_INIT; //инициализация пинов дисплея
  PWR_LCD_ON; //включаем питание дисплея
  LCD_ON; //разрешаем работу с диплеем

  OK_INIT; //инициализация кнопки "ок"
  DOWN_INIT; //инициализация кнопки "вниз"
  UP_INIT; //инициализация кнопки "вверх"

  for (uint32_t t = millis() + START_TIME; t > millis();); //ждем

  if (!OK_OUT) eeprom_update_byte(100, 0); //если зажата кнопка ок при запуске, сбрасываем настройки

  if (eeprom_read_byte(100) != 100) { //если настройки были сброшены, калибруем таймер и восстанавливаем из переменных
    wdt_calibrate(); //калибруем таймер
    setings_update(); //обновляем настройки
    eeprom_update_byte(100, 100); //делаем метку
  }
  else { //иначе загружаем настройки из памяти
    setings_read(); //считывем настройки
    statistic_read(); //считываем статистику
  }

  PRR |= lowByte(_BV(7) | _BV(6) | _BV(2) | _BV(1)); //отключаем все лишнее (I2C | TIMER2 | SPI | UART)
  ACSR |= 1 << ACD; //отключаем компаратор

  InitLCD(contrast); //инициализируем дисплей

  if (light_lcd) LIGHT_ON; // включаем подсветку, если была включена настройками

  drawBitmap(0, 0, logo_img, 84, 24);//выводим лого
  setFont(RusFont); //установка шрифта
  print("pfuheprf...", CENTER, 40); //загрузка...

  TIMSK1 = 0; //отключаем прерывания Таймера1
  TCCR1A = 0; //отключаем OC1A/OC1B
  TCCR1B = 0b00000100; //пределитель 256

  TIME_FACT_1 = 100000 / wdt_period; //расчитываем период для секунд
  buzz_time = (TIME_BUZZ / float(1.00 / FREQ_BUZZ * 1000)); //пересчитываем частоту и время щелчков в циклы таймера
  buzz_freq = (65536 - (F_CPU / TMR1_PRESCALER) / FREQ_BUZZ); //устанавливаем частоту таймера щелчков

#if DEBUG_RETURN
  if (eeprom_read_byte(101) != 101) {
    pump_update(); //считываение параметров преобразователя из памяти
    eeprom_update_byte(101, 101); //делаем метку
  }
  else pump_read(); //считываение параметров преобразователя из памяти
#endif

  start_pump(); //первая накачка преобразователя
  WDT_enable(); //запускаем WatchDog с пределителем 2

  clrRow(4); //очистка строки 4
  clrRow(5); //очистка строки 5

  setFont(RusFont); //установка шрифта
  print("-=HFLJY=-", CENTER, 32); //-=РАДОН=-
  print("3.0.4", CENTER, 40); //версия по

  bat_check(); //опрос батареи

  EICRA = 0b00001010; //настраиваем внешнее прерывание по спаду импульса на INT0 и INT1
  EIMSK = 0b00000001; //разрешаем внешнее прерывание INT0

  for (uint32_t t = millis() + FONT_TIME; t > millis() && !check_keys();) { //ждём
    pump(); //накачка по обратной связи с АЦП
    data_convert(); //преобразование данных
  }

  clrScr(); //очистка экрана

  //----------------------------------Главная-------------------------------------------------------------
  for (;;) //главная
  {
    pump(); //накачка по обратной связи с АЦП
    low_pwr(); //отключение дисплея и подсветки, уход в сон для экономии энергии
    data_convert(); //преобразование данных
    error_messege(); //обработка ошибок
    alarm_warning(); //если фон превышен и тревога не запрещена, выводим сообщение
    stat_bat(); //обновление состояния батареи
    main_screen(); //основные режимы
  }
  return 0;
}
//------------------------Инициализация таймера 0--------------------------------------------------
void initTimer(void) //инициализация таймера 0
{
  sei(); //запрещаем прерывания глобально

  sbi(TCCR0A, WGM01);
  sbi(TCCR0A, WGM00);

  //устанавливаем пределитель 64
  sbi(TCCR0B, CS01);
  sbi(TCCR0B, CS00);

  //утанавливаем прерывание по переполнению таймера 0
  sbi(TIMSK0, TOIE0);

}
//-------------------------------Включение WDT----------------------------------------------------
void WDT_enable(void) //включение WDT
{
  uint8_t sregCopy = SREG; //Сохраняем глобальные прерывания
  cli(); //Запрещаем глобальные прерывания
  WDTCSR = ((1 << WDCE) | (1 << WDE)); //Сбрасываем собаку
  WDTCSR = 0x40; //Устанавливаем пределитель 2(режим прерываний)
  SREG = sregCopy; //Восстанавливаем глобальные прерывания
}
//-------------------------------Выключение WDT---------------------------------------------------
void WDT_disable(void) //выключение WDT
{
  uint8_t sregCopy = SREG; //Сохраняем глобальные прерывания
  cli(); //Запрещаем глобальные прерывания
  WDTCSR = ((1 << WDCE) | (1 << WDE)); //Сбрасываем собаку
  WDTCSR = 0x00; //Выключаем собаку
  SREG = sregCopy; //Восстанавливаем глобальные прерывания
}
//-------------------------------Включение питания----------------------------------------------------
#if PWR_ON_RETURN
ISR(INT1_vect) //внешнее прерывание на пине INT1 - включение питания
{
  _delay_ms(2000); //ждем 2 секунды
  if (!OK_OUT) { //если кнопка не отжата
    PRR &= ~ lowByte(_BV(0)); //включаем питание АЦП
    if (VCC_read() < LOW_BAT_POWER) { //если батарея не разряжена
      disableSleep(contrast); //включаем дисплей
      if (light_lcd) LIGHT_ON; //включаем подсветку, если была включена настройками

      drawBitmap(0, 0, logo_img, 84, 24); //выводим лого
      setFont(RusFont); //установка шрифта
      print("pfuheprf...", CENTER, 40); //загрузка...

      while (!OK_OUT); //ждем пока отпустят кнопу

      start_pump(); //первая накачка преобразователя

      WDT_enable(); //запускаем WatchDog с пределителем 2
      EIMSK = 0b00000001; //разрешаем внешнее прерывание INT0

      clrScr(); //очистка экрана

      power_off = 0; //флаг выключения питания
    }
    else { //иначе выводим предупреждение об разряженной батарее
      disableSleep(contrast); //включаем дисплей
      drawBitmap(26, 0, low_bat_img, 32, 32);
      setFont(RusFont); //установка шрифта
      print("<fnfhtz", CENTER, 32); //Батарея
      print("hfphz;tyf!", CENTER, 40); //разряжена!
      for (uint32_t t = millis() + POWER_TIME; t > millis();); //ждём
      enableSleep(); //выключаем дисплей
      PRR |= lowByte(_BV(0)); //выключаем питание ацп
    }
  }
}
#endif
//-------------------------------Детектирование частиц------------------------------------------------
ISR(INT0_vect) //внешнее прерывание на пине INT0 - считаем импульсы от счетчика 1
{
  if (rad_buff[0] != 65535) rad_buff[0]++; //нулевой элемент массива - текущий секундный замер

  switch (rad_flash) {
    case 1: RAD_FLASH_ON; break; //индикация попадания частиц
    case 2: if (!sleep) RAD_FLASH_ON; break; //индикация попадания частиц
  }
  switch (buzz_switch) {
    case 1: buzz_click(); break; //щелчок пищалкой
    case 2: if (rad_back >= warn_level_back) buzz_click(); break; //щелчок пищалкой
  }
}
//-------------------------Прерывание по переполнению wdt - 17.5мс------------------------------------
ISR(WDT_vect) //прерывание по переполнению wdt - 17.5мс
{
  tick_wdt++; //прибавляем тик

  switch (btn_state) { //таймер опроса кнопок
    case 0: if (btn_check) btn_tmr++; break; //считаем циклы
    case 1: if (btn_tmr > 0) btn_tmr--; break; //убираем дребезг
  }

  if (is_RAD_FLASH_ON) RAD_FLASH_OFF; //выключаем световую индикацию если была включена
}
//----------------------------------Преобразование данных---------------------------------------------------------
void data_convert(void) //преобразование данных
{
  static uint8_t time_1; //секундные замеры первого плеча
  static uint8_t time_2; //секундные замеры второго плеча
  static uint8_t nop_imp_tmr; //таймер отсутствия импульсов
  static uint8_t mass_switch; //переключатель массива
  static uint32_t temp; //буффер второго плеча
  static uint32_t temp_run; //буффер первого плеча
  static uint32_t tmp_buff; //общий буфер
  static float coef; //коэффициент сравнения
  static float coef_back; //коэффициент поправки на фон

  for (; tick_wdt > 0; tick_wdt--) { //если был тик, обрабатываем данные

    if (++time_wdt >= TIME_FACT_1) time_wdt = 0; //расчет времени один раз в секунду

    time_micros += wdt_period; //микросекунды * 10

#if SEARCH_RETURN
    graf_update(); //обновляем график
#endif

    if (!measur) {
      switch (time_wdt) {
        case TIME_FACT_2: //обновление статистики
          if (++stat_upd_tmr >= STAT_UPD_TIME) //если пришло время, обновляем статистику
          {
            stat_upd_tmr = 0; //сбрасываем таймер

            time_save += time_sec - time_save_old; //добавляем время
            time_save_old = time_sec; //сбрасывае счетчик времени
            rad_dose_save += rad_dose - rad_dose_old; //добавляем дозу
            rad_dose_old = rad_dose; //сбрасывае счетчик дозы

            statistic_update(); //обновление статистики
          }
          break;

        case TIME_FACT_3: //расчет текущего фона этап-1
          rad_buff[1] = rad_buff[0]; //смещаем 0-й элемент в 1-й для дальнейшей работы с ним
          rad_buff[0] = 0; //сбрасываем счетчик импульсов
          tmp_buff = 0; //сбрасываем временный буфер

#if SEARCH_RETURN
          part_count = 0; //сбрасываем буфер графика
#endif

          if (geiger_time_now < MAX_GEIGER_TIME) geiger_time_now++; //прибавляем указатель заполненности буффера

#if (GEIGER_COUNT == 1)
          if (rad_buff[1] >= COUNT_RATE) rad_buff[1] = rad_buff[1] / (1 - rad_buff[1] * DEAD_TIME); //если скорость счета больше 100имп/с, учитываем мертвое время счетчика
#endif

          for (uint8_t i = 0; i < geiger_time_now; i++) tmp_buff += rad_buff[i + 1]; //суммирование всех импульсов для расчета фона
          if (tmp_buff > 999999) tmp_buff = 999999; //переполнение

          break;

        case TIME_FACT_4: //расчет текущего фона этап-2
          if (geiger_time_now >= GEIGER_CYCLE) { //если массив заполнен на минимум начала работы коэффициентов
            if (geiger_time_now <= GEIGER_MASS) { //если не достигли предела массива сравнения
              if (geiger_time_now >= (pgm_read_byte(&time_mass[mass_switch + 1][0]) + pgm_read_byte(&time_mass[mass_switch + 1][1]))) mass_switch++; //пересчитываем текущий номер элемента массива в зависимости от заполненности массива счета
            }

            time_1 = pgm_read_byte(&time_mass[mass_switch][0]); //получаем количество секундных замеров для первого плеча
            time_2 = pgm_read_byte(&time_mass[mass_switch][1]); //получаем количество секундных замеров для второго плеча

            coef_back = 1.00; //устанавливаем первичный коэффициент
            for (uint8_t i = MASS_BACK; i > 0; i--) {
              if (rad_back >= pgm_read_word(&back_mass[i - 1]) && rad_back < pgm_read_word(&back_mass[i])) {
                coef_back = pgm_read_float(&coef_back_mass[i - 1]); //пересчитывем фон для коррекции по заданным коэффициентам в массиве
                break;
              }
            }
          }
          break;

        case TIME_FACT_5: //расчет текущего фона этап-3
          if (geiger_time_now >= GEIGER_CYCLE) { //если массив заполнен на минимум начала работы коэффициентов

            coef = pgm_read_float(&coef_time_mass[mass_switch]) * coef_back; //получаем коэффициент из массива для сравнения на скачок/спад

#if COEF_DEBUG //отладка коэффициента
            debug_coef = coef;
#endif

            temp_run = 0; //сбрасываем буффер первого плеча
            temp = 0; //сбрасываем буффер второго плеча
            for (uint8_t i = 0; i < time_1; i++) temp_run += rad_buff[i + 1]; //запоняем буффер первого плеча
            for (uint8_t i = time_1; i < (time_1 + time_2); i++) temp += rad_buff[i + 1]; //запоняем буффер вторго плеча
          }
          break;

        case TIME_FACT_6: //расчет текущего фона этап-4
          if (geiger_time_now >= GEIGER_CYCLE) { //если массив заполнен на минимум начала работы коэффициентов

            if (temp_run && temp) {
              now = ((float)temp_run / time_1) / ((float)temp / time_2); //получаем текущее соотношение первого плеча ко второму

              if (now > coef || now < (1.00 / coef)) { //если видим скачок или спад
                tmp_buff = 0; //сбрасываем текущий буфер
                uint8_t min_bit = pgm_read_byte(&time_mass[0][0]); //находим минимальный счет
                for (uint8_t i = min_bit; i < MAX_GEIGER_TIME; i++) rad_buff[i + 1] = 0; //стираем все лишнее
                geiger_time_now = min_bit; //возврачаемся к первым двух секундным замерам
                for (uint8_t i = 0; i < min_bit; i++) tmp_buff += rad_buff[i + 1]; //запоняем буффер первого плеча
                mass_switch = 0; //сбрасываем позицию переключения
                rad_mid_buff = 0; //стираем буфер усреднения
                first_mid = 0; //показываем что это первый замер
                tmr_mid = 0; //обнуляем таймер среднего замера
              }
            }
          }
          break;

        case TIME_FACT_7: //расчет текущего фона этап-5
          if (geiger_time_now > 1) rad_back = tmp_buff * ((float)GEIGER_TIME / geiger_time_now); //расчет фона мкР/ч

#if (GEIGER_COUNT != 1)
          rad_back = rad_back / GEIGER_COUNT;
#endif

          for (uint8_t k = MAX_GEIGER_TIME; k > 1; k--) rad_buff[k] = rad_buff[k - 1]; //перезапись массива
          break;

        case TIME_FACT_8: //средний и максимальный фон
          if (geiger_time_now >= GEIGER_CYCLE) { //если достаточно данных в массиве
            rad_mid_buff += rad_back; //заполняем буфер усреднения

            if (++tmr_mid >= (mid_rad_time[mid_level] * 60)) { //если время пришло, усредняем значение
              rad_mid = rad_mid_buff / (mid_rad_time[mid_level] * 60); //усредняем фон, добавляем в расчет предыдущее усреденение
              rad_mid_buff = 0; //сбрасываем буфер усреднения
              tmr_mid = 0; //сбрасываем таймер усреднения
              first_mid = 1; //устанавливаем флаг запрета первичного посекундного усреднения
            }

            if (rad_back > rad_max) rad_max = rad_back; //фиксируем максимум фона
          }
          break;

        case TIME_FACT_9: //расчет текущей и накопленной дозы
          if ((rad_sum += rad_buff[1]) > 999999UL * 3600 / GEIGER_TIME) rad_sum = 999999UL * 3600 / GEIGER_TIME; //сумма импульсов
          rad_dose = (rad_sum * GEIGER_TIME / 3600); //расчитаем дозу
          break;

        case TIME_FACT_10: //расчет данных для графика
#if SEARCH_RETURN //если выбран режим "поиск"
          //--------------------------------------
#if TYPE_SERCH_UNIT
          if (tm >= TIME_FACT_1 && !serch_disable) rad_imp = rad_buff[1]; //считаем кол-во импульсов в сек.
#else
          if (tm >= TIME_FACT_1 && !serch_disable) rad_imp = rad_buff[1]; //считаем кол-во импульсов в сек.
          if (tm >= TIME_FACT_1 && !serch_disable) rad_scan += rad_buff[1]; //считаем общее количество частиц
#endif
          //--------------------------------------
#else //иначе отображаем график в режиме "фон"
          //--------------------------------------
          uint16_t graf_max = 0;
#if TYPE_GRAF_MOVE //слева-направо
          for (uint8_t i = 75; i > 0; i--) {
            graf_buff[i] = graf_buff[i - 1]; //сдвигаем массив
            if (graf_buff[i] > graf_max) graf_max = graf_buff[i];
          }
          graf_buff[0] = rad_buff[1]; //новое значение в последнюю ячейку
          if (graf_buff[0] > graf_max) graf_max = graf_buff[0];

          if (graf_max > 15) maxLevel = graf_max * GRAF_COEF_MAX; //если текущий замер больше максимума
          else maxLevel = 15;
#else //справа-налево
          for (uint8_t i = 0; i < 75; i++) {
            graf_buff[i] = graf_buff[i + 1]; //сдвигаем массив
            f (graf_buff[i] > graf_max) graf_max = graf_buff[i];
          }
          graf_buff[75] = rad_buff[1]; //новое значение в последнюю ячейку
          if (graf_buff[75] > graf_max) graf_max = graf_buff[75];

          if (graf_max > 15) maxLevel = graf_max * GRAF_COEF_MAX; //если текущий замер больше максимума
          else maxLevel = 15;
#endif
          //--------------------------------------
#endif
          break;

        case TIME_FACT_11: //обработка тревоги
          if (!alarm_dose_disable && (rad_dose - alarm_dose_wait) >= alarm_level_dose) {
            alarm_switch = 2;  //превышение дозы 2
            break;
          }
          else if (!alarm_dose_disable && (rad_dose - warn_dose_wait) >= warn_level_dose) {
            alarm_switch = 4;  //превышение дозы 1
            break;
          }

          if (geiger_time_now >= GEIGER_CYCLE || rad_back >= RAD_PRE_WARN) {
            if (!alarm_back_disable && !alarm_back_wait && rad_back >= alarm_level_back) {
              alarm_switch = 1;  //превышение фона 2
              break;
            }
            else if (!alarm_back_disable && !warn_back_wait && rad_back >= warn_level_back) {
              alarm_switch = 3;  //превышение фона 1
              break;
            }
          }

          if (rad_back < warn_level_back && warn_back_wait) warn_back_wait = 0; //сброс предупреждения
          if (rad_back < alarm_level_back && alarm_back_wait) alarm_back_wait = 0; //сброс тревоги

          if (alarm_switch) { //иначе ждем понижения фона
            _vibro_off(); //выключаем вибрацию
            buzz_read(); //чтение состояния щелчков
            alarm_switch = 0; //устанавливаем признак отсутствия тревоги
          }
          break;

#if ERRORS_RETURN
        case TIME_FACT_12: //проверка на наличие импульсов от счетчика
          if (!rad_buff[1]) { //если нету импульсов в обменном буфере
            if (nop_imp_tmr++ >= IMP_ERROR_TIME) { //считаем время до вывода предупреждения
              error = 4; //устанавливаем ошибку 4 нету импульсов
              nop_imp_tmr = 0; //сбрасываем таймер
            }
          }
          else nop_imp_tmr = 0; //иначе импульсы возобновились
          break;
#endif
      }
    }

    switch (time_wdt) {
      case TIME_FACT_13:
#if !MESSUR_OR_PWR
        switch (measur) { //разностный замер
          case 1: if (time_switch < (diff_measuring[pos_measur] * 60)) time_switch ++; //прибавляем секунду
            else next_measur = 1; //иначе время вышло
            if (!next_measur) first_froze += rad_buff[0]; //если идет замер, заполняем буфер первого замера
            rad_buff[0] = 0; //сбрасывает счетчик частиц
            break;
          case 2: if (time_switch < (diff_measuring[pos_measur] * 60)) time_switch ++; //прибавляем секунду
            else next_measur = 1; //иначе время вышло
            if (!next_measur) second_froze += rad_buff[0]; //если идет замер, заполняем буфер второго замера
            rad_buff[0] = 0; //сбрасывает счетчик частиц
            break;
        }
#endif
        break;

      case TIME_FACT_14:
        bat_update = 0; //устанавливаем флаг для обновления батареи
        time_sec = time_micros / 100000; //считаем секунды
        break;

      case TIME_FACT_15:
        if (!sleep) scr = 0; //устанавливаем флаг для обновления экрана
        break;
    }
  }
}
//-------------------------Режим пониженного энергопотребления----------------------------------------------------
void low_pwr(void)
{
  if (sleep_switch == 2 && rad_back < RAD_PWR_MANAGER) { //если сон разрешен
    if (buzz_on || alarm_switch) waint_pwr(); //если включен бузер или тревога - режим ожидания
    else if (sleep && rad_back < RAD_PWR_DOWN) sleep_pwr(); //если спим и фон меньше установленного - глубокий сон
    else save_pwr(); //иначе - режим энергосбережения
  }
  else waint_pwr(); //иначе - режим ожидания

  if (rad_back > RAD_SLEEP_OUT) cnt_pwr = 0; //если фон выше установленного предела - просыпаемся

  if (cnt_pwr == TIME_SLEEP && sleep_switch == 2) { //если пришло время спать и сон не запрещен
    enableSleep(); //уводим в сон дисплей
    sleep = 1; //выставляем флаг сна
    buzz_switch = 0; //запрещаем щелчки
  }

  else if (cnt_pwr == TIME_BRIGHT) { //если пришло время выключить подсветку
    LIGHT_OFF; //выключаем подсветку
    light = 1; //выставляем флаг выключенной подсветки
  }
  else if (!cnt_pwr) { //если пора проснуться
    if (sleep) //если спали
    {
      disableSleep(contrast); //выводим дисплей из сна
      LIGHT_ON; //включаем подсветку
      sleep = 0; //сбрасываем флаг сна
      light = 0; //сбрасываем флаг подсветки
      buzz_read(); //восстанавливаем настройку щелчков
      scr = 0; //обновляем экран
    }
    if (light) //если выключели подсветку
    {
      LIGHT_ON; //включаем подсветку
      light = 0; //сбрасываем флаг подсветки
    }
  }
}
//-------------------------------------Ожидание--------------------------------------------------------
void waint_pwr(void) //ожидание
{
  SMCR = (0x0 << 1) | (1 << SE);  //устанавливаем режим сна idle

  MCUCR = (0x03 << 5); //выкл bod
  MCUCR = (0x02 << 5);

  asm ("sleep");  //с этого момента спим.
}
//-------------------------------------Энергосбережение--------------------------------------------------------
void save_pwr(void) //энергосбережение
{
  SMCR = (0x6 << 1) | (1 << SE);  //устанавливаем режим сна standby

  MCUCR = (0x03 << 5); //выкл bod
  MCUCR = (0x02 << 5);

  asm ("sleep");  //с этого момента спим.
}
//-------------------------------------Глубокий сон--------------------------------------------------------
void sleep_pwr(void) //энергосбережение
{
  SMCR = (0x2 << 1) | (1 << SE);  //устанавливаем режим сна powerdown

  MCUCR = (0x03 << 5); //выкл bod
  MCUCR = (0x02 << 5);

  asm ("sleep");  //с этого момента спим.
}
//-------------------------------------Выключение устройства----------------------------------------------------
void power_down(void) //выключение устройства
{
  power_off = 1; //флаг выключения питания

  //=======================================================
  time_save += time_sec - time_save_old; //добавляем время
  rad_dose_save += rad_dose - rad_dose_old; //добавляем дозу

  time_save_old = time_sec; //сбрасывае счетчик времени
  rad_dose_old = rad_dose; //сбрасывае счетчик дозы

  statistic_update(); //обновление статистики
  //=======================================================

  LIGHT_OFF; //выключаем подсветку
  enableSleep(); //выключаем дисплей
  TIMER1_STOP; //выключаем таймер
  BUZZ_CLR; //выключаем бузер
  FLASH_OFF; //выключаем фонарь

  WDT_disable();  //выключаем watchdog

#if PWR_ON_RETURN
  EIMSK = 0b00000010; //разрешаем внешнее прерывание INT2
#else
  EIMSK = 0b00000000; //запрещаем внешние прерывание
#endif

  PRR |= lowByte(_BV(0)); //выключаем питание АЦП

  while (power_off) sleep_pwr();
}
//---------------------------------Прерывание Timer1---------------------------------------
ISR(TIMER1_COMPA_vect) //прерывание Timer1 - сигнал для пищалки
{
  TCNT1 = TIMER1_PRELOAD; //устанавливаем частоту

  switch (is_BUZ_SET) { //проверяем текущее состояния бита бузера
    case 0: BUZZ_SET; break; //включаем бузер
    case 1: BUZZ_CLR; break; //выключаем бузер
  }

  switch (cnt_puls--) { //считаем циклы времени работы бузера
    case 0: BUZZ_CLR; TIMER1_STOP; buzz_on = false; break; //если циклы кончились, выключаем таймер
  }
}
//--------------------------------Аналог tone(), с блекджеком и ...----------------------------------
void buzz_pulse(uint16_t freq, uint8_t time) //генерация частоты бузера (частота 10..10000, длительность мс.)
{
  cnt_puls = time / float(1.00 / freq * 1000); //пересчитываем частоту и время в циклы таймера
  TIMER1_PRELOAD = (65536 - (F_CPU / TMR1_PRESCALER) / freq); //устанавливаем частоту таймера
  buzz_on = true; //поднимаем флаг работы бузера
  TIMER1_START; //запускаем таймер
}
//--------------------------------Щелчок пищалкой-------------------------------------------------
void buzz_click(void) //щелчок пищалкой
{
  cnt_puls = buzz_time; //устанавливаем длительность щелчка
  TIMER1_PRELOAD = buzz_freq; //устанавливаем частоту щелчка
  buzz_on = true; //поднимаем флаг работы бузера
  TIMER1_START; //запускаем таймер
}
//-----------------------------Проверка кнопок----------------------------------------------------
uint8_t check_keys(void) //проверить клавиатуру
{
  static uint8_t btn_set; //флаг признака действия
  static uint8_t btn_switch; //флаг мультиопроса кнопок

  switch (btn_switch) { //переключаемся в зависимости от состояния мультиопроса
    case 0:
      if (!OK_OUT) { //если нажата кл. ок
        btn_switch = 1; //выбираем клавишу опроса
        btn_state = 0; //обновляем текущее состояние кнопки
      }
      else if (!DOWN_OUT) { //если нажата кл. вниз
        btn_switch = 2; //выбираем клавишу опроса
        btn_state = 0; //обновляем текущее состояние кнопки
      }
      else if (!UP_OUT) { //если нажата кл. вверх
        btn_switch = 3; //выбираем клавишу опроса
        btn_state = 0; //обновляем текущее состояние кнопки
      }
      else btn_state = 1; //обновляем текущее состояние кнопки
      break;
    case 1: btn_state = OK_OUT; break; //опрашиваем клавишу ок
    case 2: btn_state = DOWN_OUT; break; //опрашиваем клавишу вниз
    case 3: btn_state = UP_OUT; break; //опрашиваем клавишу вверх
  }

  switch (btn_state) { //переключаемся в зависимости от состояния клавиши
    case 0:
      if (btn_check) { //если разрешена провекрка кнопки
        if (btn_tmr > BTN_HOLD_TICK) { //если таймер больше длительности удержания кнопки
          btn_tmr = BTN_GIST_TICK; //сбрасываем таймер на антидребезг
          if (!light && !sleep) { //если не спим и если подсветка включена
            btn_set = 2; //поднимаем признак удержания
            cnt_pwr = 0; //сбрасываем таймер сна
          }
          btn_check = 0; //запрещем проврку кнопки
        }
      }
      break;

    case 1:
      if (btn_tmr > BTN_GIST_TICK) { //если таймер больше времени антидребезга
        btn_tmr = BTN_GIST_TICK; //сбрасываем таймер на антидребезг
        if (!light && !sleep) btn_set = 1; //если не спим и если подсветка включена, поднимаем признак нажатия
        btn_check = 0; //запрещем проврку кнопки
        cnt_pwr = 0; //сбрасываем таймер сна
        if (!knock_disable) buzz_pulse(FREQ_BEEP, TIME_BEEP); //щелчок пищалкой
      }
      else if (!btn_tmr) {
        btn_check = 1; //разрешаем проврку кнопки
        btn_switch = 0; //сбрасываем мультиопрос кнопок
      }
      break;
  }

  switch (btn_set) { //переключаемся в зависимости от признака нажатия
    case 0: return 0; //клавиша не нажата, возвращаем 0
    case 1:
      btn_set = 0; //сбрасываем признак нажатия
      switch (btn_switch) { //переключаемся в зависимости от состояния мультиопроса
        case 1: return 5; //ok press, возвращаем 5
        case 2: return 2; //down press, возвращаем 2
        case 3: return 3; //up press, возвращаем 3
      }
      break;

    case 2:
      btn_set = 0; //сбрасываем признак нажатия
      switch (btn_switch) { //переключаемся в зависимости от состояния мультиопроса
        case 1: return 6; //ok hold, возвращаем 6
        case 2: return 1; //down hold, возвращаем 1
        case 3: return 4; //up hold, возвращаем 4
      }
      break;
  }
}
//---------------------------------Воспроизведение мелодии---------------------------------------
void _melody_chart(uint16_t arr[][3], uint8_t n, uint8_t s) //воспроизведение мелодии
{
  static uint8_t i; //переключатель мелодии
  static uint8_t signature; //переключатель мелодии
  static uint32_t timer_sound; //таймер мелодии

  if (signature != s) {
    i = 0;
    signature = s;
  }
  if (millis() > timer_sound) {
    buzz_pulse(pgm_read_word(&arr[i][0]), pgm_read_word(&arr[i][1]));
    timer_sound = millis() + pgm_read_word(&arr[i][2]);
    if (++i > n - 1) i = 0;
  }
}
//-------------------------------Оостановка замера----------------------------------------------------------
void measur_stop(void) //остановка замера
{
  uint8_t n = 0; //курсор

  clrScr(); //очистка экрана
  setFont(RusFont); //установка шрифта
  print("Jcnfyjdbnm", CENTER, 8); //Остановить
  print("pfvth&", CENTER, 16); //замер?

  while (1) {
    pump();//накачка по обратной связи с АЦП
    low_pwr(); //отключение дисплея и подсветки, уход в сон для экономии энергии
    data_convert(); //преобразование данных

    choice_menu(n); //меню выбора

    switch (check_keys()) {

      case 2: //Down key
        if (n > 0) n--;
        break;
      case 3: //Up key
        if (n < 1) n++;
        break;

      case 5: //select key
        switch (n) {
          case 1:
            measur = 0; //выключаем замер
            time_switch = 0; //сбрасываем таймер
            next_measur = 0; //сбрасываем флаг продолжения замера
            alarm_measur = 0; //разрешаем оповещение окончания замера
            first_froze = 0; //сбрасываем счетчик 1-го замера
            second_froze = 0; //сбрасываем счетчик 2-го замера
            return;

          case 0:
            scr = 0; //разрешаем обновление экрана
            return;
        }
        break;
    }
  }
}
//-------------------------------Окончание замера----------------------------------------------------------
void measur_warning(void) //окончание замера
{
  if (next_measur && !alarm_measur) { //если поднят флаг следующего замера и оповещение окончания замера разешено

    cnt_pwr = 0; //обнуляем счетчик
    low_pwr(); //просыпаемся если спали

    clrScr(); //очистка экрана
    setFont(RusFont); //установка шрифта
    print("Pfvth", CENTER, 16); //Замер
    print("pfdthity!", CENTER, 24); //завершен!

    for (uint32_t t = millis() + MASSEGE_TIME; t > millis() && !check_keys();) { //ждём
      pump();//накачка по обратной связи с АЦП
      data_convert(); //преобразование данных
#if MEASUR_SOUND
      _melody_chart(measur_sound, SAMPLS_MEASUR, 0); //играем волшебную мелодию
#endif
    }
    switch (measur) {
      case 1: alarm_measur = 1; break; //запрещаем повторное оповещение
      case 2: measur = 0; time_switch = 0; alarm_measur = 1; break;
    }
    scr = 0; //разрешаем обновления экрана
  }
}
//-------------------------------Режим замера----------------------------------------------------------
void measur_menu(void) //режим замера
{
  uint16_t result = 0; //результат
  boolean n = 0; //анимация окончания замера

  alarm_measur = 1; //запрещаем оповещение окончания замера
  next_measur = 1; //поднимаем флаг продолжения замера

  scr = 0; //разрешаем обновления экрана

  while (1) {
    error_messege(); //обработка ошибок
    pump();//накачка по обратной связи с АЦП
    low_pwr(); //отключение дисплея и подсветки, уход в сон для экономии энергии
    data_convert(); //преобразование данных
    stat_bat(); //обновление состояния батареи
    measur_warning(); //оповещение об окончании замера

    if (!scr) {
      scr = 1; //устанавливаем флаг
      cnt_pwr = 0; //обнуляем счетчик

      clrScr(); //очистка экрана
      drawBitmap(0, 0, mesur_img, 84, 8); //устанавлваем фон

      switch (measur) {
        case 0: //результат
          if (first_froze > second_froze) result = (first_froze - second_froze) / ((60.0 / GEIGER_TIME) * diff_measuring[pos_measur]);
          else result = (second_froze - first_froze) / ((60.0 / GEIGER_TIME) * diff_measuring[pos_measur]);

          init_rads_unit(1, result, 1, 4, 1, 8, 0, 54, 16); //результат

          if (next_measur) {
            switch (n) {
              case 0: drawBitmap(19, 24, measur_result_img, 45, 8); n = 1; break; //результат
              case 1: drawBitmap(11, 24, measur_ok_img, 15, 8); drawBitmap(27, 24, measur_first_img, 47, 8); n = 0; break; //ок - первый замер
            }
          }
          else drawBitmap(19, 24, measur_result_img, 45, 8); //результат

          print("1-q&", LEFT, 32);            //строка 1 1-й замер
          print("bvg", 66, 32);          //строка 1 имп
#if (TYPE_CHAR_FILL > 44)
          printNumI(first_froze, 28, 32, 6, TYPE_CHAR_FILL); //строка 1
#else
          printNumI(first_froze, 28, 32, 6, 32); //строка 1
#endif
          print("2-q&", LEFT, 40);            //строка 2 2-й замер
          print("bvg", 66, 40);          //строка 2 имп
#if (TYPE_CHAR_FILL > 44)
          printNumI(second_froze, 28, 40, 6, TYPE_CHAR_FILL); //строка 2
#else
          printNumI(second_froze, 28, 40, 6, 32); //строка 2
#endif

          break;

        case 1: //1-й замер
          if (next_measur) {
            switch (n) {
              case 0: drawBitmap(18, 24, measur_first_img, 47, 8); n = 1; break; //первый замер
              case 1: drawBitmap(3, 24, measur_ok_img, 15, 8); drawBitmap(18, 24, measur_second_img, 62, 8); n = 0; break; //ок - второй замер
            }
          }
          else drawBitmap(18, 24, measur_first_img, 47, 8); //первый замер

          setFont(MediumNumbers); //установка шрифта
          printNumI(first_froze, 5, 8, 5, TYPE_CHAR_FILL); //строка 1

          setFont(RusFont); //установка шрифта
          print("bvg", 66, 16);          //строка 1 имп
          printNumI(diff_measuring[pos_measur], 50, 40, 2, 32); //минут всего
          print("vby", RIGHT, 40);            //строка 1 мин
#if (TYPE_CHAR_FILL > 44)
          printNumI(((diff_measuring[pos_measur] * 60 - time_switch) / 60), 0, 40, 2, TYPE_CHAR_FILL); //минут
#else
          printNumI(((diff_measuring[pos_measur] * 60 - time_switch) / 60), 0, 40, 2, 32); //минут
#endif
          print("&", 12, 40);            //строка 2
          printNumI((diff_measuring[pos_measur] * 60 - time_switch) % 60, 18, 40, 2, 48); //секунд

          _screen_line(0, map(time_switch, 0, diff_measuring[pos_measur] * 60, 5, 82), 1, 1, 32); //шкала времени до сохранения дозы
          break;

        case 2: //2-й замер
          setFont(MediumNumbers); //установка шрифта
          printNumI(second_froze, 5, 8, 5, TYPE_CHAR_FILL); //строка 1

          setFont(RusFont); //установка шрифта
          print("bvg", 66, 16);          //строка 1 имп
          printNumI(diff_measuring[pos_measur], 50, 40, 2, 32); //минут всего
          print("vby", RIGHT, 40);            //строка 1 мин
#if (TYPE_CHAR_FILL > 44)
          printNumI(((diff_measuring[pos_measur] * 60 - time_switch) / 60), 0, 40, 2, TYPE_CHAR_FILL); //минут
#else
          printNumI(((diff_measuring[pos_measur] * 60 - time_switch) / 60), 0, 40, 2, 32); //минут
#endif
          print("&", 12, 40);            //строка 2
          printNumI((diff_measuring[pos_measur] * 60 - time_switch) % 60, 18, 40, 2, 48); //секунд

          drawBitmap(11, 24, measur_second_img, 62, 8); //второй замер
          _screen_line(0, map(time_switch, 0, diff_measuring[pos_measur] * 60, 5, 82), 1, 1, 32); //шкала времени до сохранения дозы
          break;
      }
    }
    //+++++++++++++++++++++  опрос кнопок  +++++++++++++++++++++++++++
    switch (check_keys())
    {
      case 1: //Down key hold
        measur = 0; //выключаем замер
        time_switch = 0; //сбрасываем таймер
        next_measur = 0; //сбрасываем флаг следующего замера
        alarm_measur = 0; //разрешаем оповещение оканчания замера
        first_froze = 0; //сбрасываем счетчик 1-го замера
        second_froze = 0; //сбрасываем счетчик 2-го замера
        scr = 0; //разрешаем обновления экрана
        break;

      case 2: //Down key
        if (measur) measur_stop(); //если идет замер, спрашиваем нужно ли остановить замер
        scr = 0; //разрешаем обновления экрана
        break;

      case 3: //Up key
        if (measur) measur_stop(); //если идет замер, спрашиваем нужно ли остановить замер
        scr = 0; //разрешаем обновления экрана
        break;

      case 4: //Up key hold
        //здесь что-то должно было быть :)
        break;

      case 5: //select key
        if (!measur) {
          measur = 1; //включаем замер
          next_measur = 0; //сбрасываем флаг следующего замера
          alarm_measur = 0; //разрешаем оповещение оканчания замера
          first_froze = 0; //сбрасываем счетчик 1-го замера
          second_froze = 0; //сбрасываем счетчик 2-го замера
        }
        else if (next_measur) {
          switch (measur) {
            case 1: measur = 2; next_measur = 0; time_switch = 0; alarm_measur = 0; n = 0; break;
          }
        }
        scr = 0; //разрешаем обновления экрана
        break;

      case 6: //hold select key
        if (measur) measur_stop(); //если идет замер, спрашиваем нужно ли остановить замер
        switch (measur) {
          case 0: return;
          case 1: scr = 0; break; //разрешаем обновления экрана
        }
        break;
    }
  }
}
//-------------------------------Тревога----------------------------------------------------------
void alarm_messege(boolean set, boolean sound, char *mode) //тревога
{
  uint8_t pos = 21 + (6 * set); //определяем позицию
  uint32_t rad_set; //текущие данные фона/дозы

  cnt_pwr = 0; //обнуляем счетчик
  low_pwr(); //просыпаемся если спали

  buzz_switch = 0; //запретить звуковую индикацию импульсов

  clrScr(); //очистка экрана
  setFont(RusFont); //установка шрифта
  drawBitmap(26, 0, rad_img, 32, 32);
  print("Nhtdjuf!", CENTER, 32); //Тревога!

  scr = 0; //разрешаем обновления экрана

  while (1)
  {
    pump(); //накачка по обратной связи с АЦП
    data_convert(); //преобразование данных

    if (!scr)
    {
      scr = 1;

      clrRow(5); //очистка строки 5

      switch (set) {
        case 0: rad_set = rad_back; break;
        case 1: rad_set = rad_dose; break;
      }
      print(mode, LEFT, 40); //фон
      init_rads_unit(0, rad_set, 1, 5, pos, 40, set, RIGHT, 40); //результат
    }

    //==================================================================
    if (!sound) _melody_chart(alarm_sound, SAMPLS_ALARM, 1); //играем волшебную мелодию
    _vibro_on(); //включаем вибрацию
    //==================================================================
#if ALARM_AUTO_DISABLE
    if (check_keys() || (!set && rad_back < (alarm_level_back * ALARM_AUTO_GISTERESIS))) //если нажата любая кнопка или фон упал отключаем тревогу
#else
    if (check_keys()) //если нажата любая кнопка отключаем тревогу
#endif
    {
      _vibro_off(); //выключаем вибрацию
      buzz_read(); //восстанавливаем настроку щелчков

      switch (set) {
        case 0: alarm_back_wait = 1; warn_back_wait = 1; break;
        case 1: alarm_dose_wait = warn_dose_wait = rad_dose; break;
      }
      alarm_switch = 0; //устанавливаем признак отсутствия тревоги
      clrScr(); // Очистка экрана
      scr = 0; //разрешаем обновление экрана
      return;
    }
  }
}
//-------------------------------Предупреждение----------------------------------------------------------
void _vibro_on(void) //предупреждение
{
  static uint8_t n; //переключатель вибрации
  static uint32_t timer_vibro; //таймер вибрации

#if (TYPE_ALARM_IND == 1)
  if (millis() > timer_vibro) { //вибрируем танго и мигаем фонариком
    switch (n) {
      case 0: VIBRO_ON; FLASH_ON; n++; timer_vibro = millis() + VIBRO_TIME_ON; break;
      case 1: VIBRO_OFF; FLASH_OFF; n++; timer_vibro = millis() + VIBRO_TIME_OFF; break;
      case 2: VIBRO_ON; FLASH_ON; n++; timer_vibro = millis() + VIBRO_TIME_ON; break;
      case 3: VIBRO_OFF; FLASH_OFF; n++; timer_vibro = millis() + VIBRO_TIME_OFF; break;
      case 4: VIBRO_ON; FLASH_ON; n++; timer_vibro = millis() + VIBRO_TIME_ON; break;
      case 5: VIBRO_OFF; FLASH_OFF; n = 0; timer_vibro = millis() + VIBRO_TIME_WAINT; break;
    }
  }
#elif (TYPE_ALARM_IND == 2)
  if (millis() > timer_vibro) { //вибрируем танго и мигаем подсветкой
    switch (n) {
      case 0: VIBRO_ON; LIGHT_ON; n++; timer_vibro = millis() + VIBRO_TIME_ON; break;
      case 1: VIBRO_OFF; LIGHT_OFF; n++; timer_vibro = millis() + VIBRO_TIME_OFF; break;
      case 2: VIBRO_ON; LIGHT_ON; n++; timer_vibro = millis() + VIBRO_TIME_ON; break;
      case 3: VIBRO_OFF; LIGHT_OFF; n++; timer_vibro = millis() + VIBRO_TIME_OFF; break;
      case 4: VIBRO_ON; LIGHT_ON; n++; timer_vibro = millis() + VIBRO_TIME_ON; break;
      case 5: VIBRO_OFF; LIGHT_OFF; n = 0; timer_vibro = millis() + VIBRO_TIME_WAINT; break;
    }
  }
#else
  if (millis() > timer_vibro) { //вибрируем танго
    switch (n) {
      case 0: VIBRO_ON; n++; timer_vibro = millis() + VIBRO_TIME_ON; break;
      case 1: VIBRO_OFF; n++; timer_vibro = millis() + VIBRO_TIME_OFF; break;
      case 2: VIBRO_ON; n++; timer_vibro = millis() + VIBRO_TIME_ON; break;
      case 3: VIBRO_OFF; n++; timer_vibro = millis() + VIBRO_TIME_OFF; break;
      case 4: VIBRO_ON; n++; timer_vibro = millis() + VIBRO_TIME_ON; break;
      case 5: VIBRO_OFF; n = 0; timer_vibro = millis() + VIBRO_TIME_WAINT; break;
    }
  }
#endif
}
//-------------------------------Предупреждение----------------------------------------------------------
void _vibro_off(void) //предупреждение
{
#if (TYPE_ALARM_IND == 1)
  FLASH_OFF; //выключаем фонарик
  VIBRO_OFF; //выключаем вибрацию
#elif (TYPE_ALARM_IND == 2)
  if (light_lcd) LIGHT_ON; //включаем подсветку, если была включена настройками
  else LIGHT_OFF; //иначе выключаем подсветку
  VIBRO_OFF; //выключаем вибрацию
#else
  VIBRO_OFF; //выключаем вибрацию
#endif
}
//-------------------------------Предупреждение----------------------------------------------------------
void warn_messege(boolean set, boolean sound) //предупреждение
{
  buzz_switch = 0; //запрещаем щелчки
  cnt_pwr = 0; //обнуляем счетчик сна

  switch (set) { //переключаемся на экран тревоги
    case 0: switch (scr_mode) { //фон
        case 1:
        case 2:
          scr_mode = 0;
          return;
      }
      break;
    case 1: switch (scr_mode) { //доза
        case 0:
        case 2:
          scr_mode = 1;
          dose_mode = 0;
          return;
      }
      break;
  }
  //==================================================================
  if (!sound) _melody_chart(warn_sound, SAMPLS_WARN, 2); //играем волшебную мелодию
  _vibro_on(); //включаем вибрацию
  //==================================================================
}
//-------------------------------Выбор тревоги----------------------------------------------------------
void alarm_warning(void) //выбор тревоги
{
  switch (alarm_switch) {
    case 1: alarm_messege(0, alarm_back_sound_disable, "Ajy"); break; //фон 2
    case 2: alarm_messege(1, alarm_dose_sound_disable, "Ljpf"); break; //доза 2
    case 3: warn_messege(0, alarm_back_sound_disable); break; //фон 1
    case 4: warn_messege(1, alarm_dose_sound_disable); break; //доза 1
  }
}
//-----------------------------------Первая накачка--------------------------------------------
void start_pump(void) //первая накачка
{
  uint32_t i = millis() + START_PUMP_TIME; //таймер авто-выхода

  for (hv_adc = Read_HV(); hv_adc < ADC_value; hv_adc = Read_HV())  //значение АЦП при котором на выходе 400В
  {
    PORTD |= (1 << 5); //пин накачки
    for (uint8_t c = puls; c > 0; c--) asm("nop"); //ждем
    PORTD &= ~(1 << 5); //пин накачки

    if (i < millis()) break; //если время вышло, останавливаем накачку

    _screen_line(0, map(hv_adc, 0, ADC_value, 0, 64), 0, 10, 32); //прогресс бар накачки преобразователя
  }
}
//----------------------------Накачка по обратной связи с АЦП---------------------------------
void pump(void) //накачка по обратной связи с АЦП
{
  uint8_t i = 0; //счетчик циклов переполнения

  for (hv_adc = Read_HV(); hv_adc < ADC_value; hv_adc = Read_HV()) { //значение АЦП при котором на выходе 400В

    if (++i >= CYCLE_OVERFLOW) { //защита от зацикливания
#if ERRORS_RETURN
      if (hv_adc < 10) error = 3; //устанавливаем ошибку 3 кз преобразователя
      else error = 2; //устанавливаем ошибку 2 перегрузка преобразователя
#endif
      break;
    }

    PORTD |= (1 << 5); //пин накачки
    for (uint8_t c = puls; c > 0; c--) asm("nop"); //ждем
    PORTD &= ~(1 << 5); //пин накачки

    if (sthv) speed_nak++; //считаем скорость накачки
  }
}
//------------------------Чтение напряжения преобразователя-----------------------------------
uint16_t Read_HV(void) //чтение напряжения преобразователя
{
  uint16_t result = 0; //результат опроса АЦП внутреннего опорного напряжения

#if UNO_DIP //если при компилляции выбрана плата ArduinoUNO
  ADMUX = 0b11100101; //выбор внутреннего опорного 1,1В и А5
#else //если используется промини, нано или голый камень в tqfp
  ADMUX = 0b11100110; //выбор внутреннего опорного 1,1В и А6
#endif
  ADCSRA = 0b11100111; //настройка АЦП

  for (uint8_t i = 0; i < 10; i++) //делаем 10 замеров
  {
    while ((ADCSRA & 0x10) == 0); //ждем флага прерывания АЦП
    ADCSRA |= 0x10; //сбрасываем флаг прерывания
    result += ADCH; //прибавляем замер в буфер
  }
  result /= 10; //находим среднее значение
  return result; //возвращаем результат опроса АЦП
}
//--------------------------------Чтение напряжения батареи-------------------------------------
uint16_t VCC_read(void)  //чтение напряжения батареи
{
  ADMUX = 0b01101110; //выбор внешнего опорного+BG
  ADCSRA = 0b11100111; //настройка АЦП
  _delay_ms(1);
  while ((ADCSRA & 0x10) == 0); //ждем флага прерывания АЦП
  ADCSRA |= 0x10; //сбрасываем флаг прерывания
  uint8_t resu = ADCH; //результат опроса АЦП
  return resu; //возвращаем результат опроса АЦП
}
//-----------------------------------Опрос батареи-----------------------------------------------
void bat_check(void) //опрос батареи
{
  adc_result = VCC_read(); //состояние батареи
  if (adc_result == 255) adc_result = 60; //защита от ложных данных

  if (adc_result < MIN_BAT) { //мин.напр. 3v макс.нап. 4,2v
    if (adc_result < MAX_BAT) bat = 5;  //если батарея заряжена
    else { //иначе расчитывает указатель заряда батареи
      bat = map(adc_result, MIN_BAT, MAX_BAT, 0, 5); //переводим значение в полосы акб
      bat = constrain(bat, 0, 5); //ограничиваем
    }
  }
  else bat = 0; //иначе акб разряжен
}
//-----------------------------------Заряд батареи-----------------------------------------------
void stat_bat(void) //заряд батареи
{
  static uint8_t bat_tmr; //таймер опроса заряда акб
  static uint8_t low_bat_tmr; //таймер оповещения о разряде акб

  if (!bat_update) { //если пришло время
    bat_update = 1; //сбрасываем флаг

    switch (sleep_switch) { //если сон не запрещен
      case 1: if (cnt_pwr < TIME_BRIGHT + 1) cnt_pwr++; break; //счет выключения подсветки
      case 2: if (cnt_pwr < TIME_SLEEP + 1) cnt_pwr++; break; //счет выключения подсветки и ухода в сон
    }

    if (++bat_tmr >= UPD_BAT_TIME) { //если прошло n секунд
      bat_tmr = 0; //сбрасываем таймер обновления акб
      bat_check(); //опрос батареи
    }

    //--------------------------------------------------------------------------------------
    if (++low_bat_tmr >= LOW_BAT_TIME && adc_result >= LOW_BAT_STAT) { //Если таймер истек и заряд ниже 3v, то выводим предупреждение

      buzz_switch = 0; //запретить звуковую индикацию импульсов

      clrScr(); // Очистка экрана
      drawBitmap(26, 0, low_bat_img, 32, 32); //рисуем заставку
      setFont(RusFont); //установка шрифта
      print("<fnfhtz", CENTER, 32); //Батарея
      print("hfphz;tyf!", CENTER, 40); //разряжена!

      for (uint32_t t = millis() + MASSEGE_TIME; t > millis() && !check_keys();) { //ждём
        pump(); //накачка по обратной связи с АЦП
        data_convert(); //преобразование данных
        //--------------------------------------------------------------------------------------
#if BAT_LOW_SOUND
        _melody_chart(bat_low_sound, SAMPLS_BAT_LOW, 3); //играем волшебную мелодию
#endif
        //--------------------------------------------------------------------------------------
      }
      low_bat_tmr = 0; //длительность следующей проверки 30000ms
      clrScr(); //очистка экрана
      buzz_read(); //считываем настроку щелчков
      scr = 0; //разрешаем обновление экрана
      if (!bat) power_down(); //выключение устройства
      //--------------------------------------------------------------------------------------
    }
    else if (sleep && adc_result >= LOW_BAT_STAT_SLEEP) { //если спим и батарея разрядилась

      cnt_pwr = 0; //обнуление счетчика сна
      low_pwr(); //просыпаемся

      clrScr(); //очистка экрана
      drawBitmap(26, 0, low_bat_img, 32, 32);
      setFont(RusFont); //установка шрифта
      print("<fnfhtz", CENTER, 32); //Батарея
      print("hfphz;tyf!", CENTER, 40); //разряжена!

      for (uint32_t t = millis() + MASSEGE_TIME; t > millis() && !check_keys();) { //ждём
        pump(); //накачка по обратной связи с АЦП
        data_convert(); //преобразование данных
        //--------------------------------------------------------------------------------------
#if BAT_SLEEP_LOW_SOUND
        _melody_chart(bat_sleep_low_sound, SAMPLS_BAT_SLEEP_LOW, 4); //играем волшебную мелодию
#endif
        //--------------------------------------------------------------------------------------
      }
      clrScr(); //очистка экрана
      scr = 0; //разрешаем обновление экрана
      power_down(); //выключение устройства
    }
  }
}
//-------------------------Обновление графика----------------------------------------------------
void graf_update(void) //обновление графика
{
  static uint16_t cnt; //счетчик тиков графика

  if (rad_buff[0] > part_count) {
    rad_scan_buff += rad_buff[0] - part_count; //текущее количество частиц
    part_count = rad_buff[0]; //запоминаем новое количество частиц
  }

  if (++cnt >= tm) { //расчет показаний в зависимости от фона

#if TYPE_SERCH_UNIT //если выбраны имп/с
    if (tm < TIME_FACT_1 && !serch_disable) rad_imp = rad_scan_buff * (1000 / ((wdt_period / 100.0) * tm)); //динамический персчет импульсов в сек.
#else //иначе счет кол-ва частиц
    if (tm < TIME_FACT_1 && !serch_disable) {
      rad_imp = rad_scan_buff * (1000 / ((wdt_period / 100.0) * tm)); //динамический персчет импульсов в сек.
      rad_scan += rad_scan_buff; //считаем общее количество частиц
    }
#endif

    uint16_t graf_max = 0;
#if TYPE_GRAF_MOVE //слева-направо
    if (!serch_disable) {
      for (uint8_t i = 75; i > 0; i--) {
        graf_buff[i] = graf_buff[i - 1]; //сдвигаем массив
        if (graf_buff[i] > graf_max) graf_max = graf_buff[i];
      }
      graf_buff[0] = rad_scan_buff; //новое значение в последнюю ячейку
      rad_scan_buff = 0; //сбрасываем буфер графика
      if (graf_buff[0] > graf_max) graf_max = graf_buff[0];

      if (graf_max > 22) maxLevel = graf_max * GRAF_COEF_MAX; //если текущий замер больше максимума
      else maxLevel = 22;
    }
#else //справа-налево
    if (!serch_disable) {
      for (uint8_t i = 0; i < 75; i++) {
        graf_buff[i] = graf_buff[i + 1]; //сдвигаем массив
        if (graf_buff[i] > graf_max) graf_max = graf_buff[i];
      }
      graf_buff[75] = rad_scan_buff; //новое значение в последнюю ячейку
      rad_scan_buff = 0; //сбрасываем буфер графика
      if (graf_buff[75] > graf_max) graf_max = graf_buff[75];

      if (graf_max > 22) maxLevel = graf_max * GRAF_COEF_MAX; //если текущий замер больше максимума
      else maxLevel = 22;
    }
#endif
    cnt = 0; //сброс
    graf = 0; //разрешаем обновление графика
  }

  if (rad_back > GRAF_RAD) tm = GRAF_RAD; //ускоряем движение графика с увеличением фона
  else tm = rad_back; //
  tm = map(tm, 0, GRAF_RAD, GRAF_MAX, GRAF_MIN);
}
//-------------------------Инициализация графика-----------------------------------------
void graf_init(void) //инициализация графика
{
  if (!sleep) //если режим поиск и мы не спим
  {
#if TYPE_SERCH_UNIT //если выбраны имп/с
    drawBitmap(0, 8, scan_ind_scale_img, 55, 8); //рисуем шкалу
    //--------------------------------------------------------------//
    static uint16_t n;
    static uint16_t f;

    if (rad_imp > GRAF_IND_MAX)n = GRAF_IND_MAX; //устанавливаем точки максимумов
    else n = rad_imp;
    n = map(n, 0, GRAF_IND_MAX, 2, 54); //корректируем под коэфициент
    if (n < f) f--; //добавляем плавности при уменьшении
    else f = n; //если увеличелось, отображаем сразу

    clrRow(2, f + 1, 55); //убираем лишнее
    drawBitmap(0, 16, scan_ind_img, f, 8); //рисуем полосу
    //--------------------------------------------------------------//
    drawBitmap(58, 8, imp_s_img, 26, 8); //имп/с
    setFont(RusFont); //установка шрифта
#if (TYPE_CHAR_FILL > 44)
    printNumI(rad_imp, 59, 16, 4, TYPE_CHAR_FILL); //строка 1
#else
    printNumI(rad_imp, 59, 16, 4, 32); //строка 1
#endif
#else //иначе счет кол-ва частиц
    drawBitmap(0, 8, scan_ind_scale_img, 55, 8); //рисуем шкалу
    //--------------------------------------------------------------//
    static uint16_t n;
    static uint16_t f;

    if (rad_imp > GRAF_IND_MAX)n = GRAF_IND_MAX; //устанавливаем точки максимумов
    else n = rad_imp;
    n = map(n, 0, GRAF_IND_MAX, 2, 54); //корректируем под коэфициент
    if (n < f) f--; //добавляем плавности при уменьшении
    else f = n; //если увеличелось, отображаем сразу

    clrRow(2, f + 1, 55); //убираем лишнее
    drawBitmap(0, 16, scan_ind_img, f, 8); //рисуем полосу
    //--------------------------------------------------------------//
    drawBitmap(60, 8, imp_all_img, 21, 8); //всего
    setFont(TinyNumbersDown); //установка шрифта
    printNumI(rad_scan, 58, 16, 7, TYPE_CHAR_FILL); //строка 1
#endif
    //---------------------------//
    if (!graf) {
      graf = 1; //запрещаем обновление графика

#if TYPE_GRAF_MOVE //слева-направо
      for (uint8_t i = 4; i < 80; i++) {
        graf_lcd(map(graf_buff[i - 4], 0, maxLevel, 0, 22), i); //инициализируем график
      }
#else //справа-налево
      for (uint8_t i = 79; i > 3; i--) {
        graf_lcd(map(graf_buff[i - 4], 0, maxLevel, 0, 22), i); //инициализируем график
      }
#endif
    }
  }
}
//--------------------------------Отрисовка графика-------------------------------------
void graf_lcd(uint8_t r, uint8_t p) //отрисовка графика
{
#if SEARCH_RETURN //если выбран режим "поиск"
  if (r > 22)r = 22; //ограничивываем максимум
  if (p == 4) drawBitmap(0, 24, scan_alt_left_img, 4, 24); //рисуем левую шкалу
  if (p == 79) drawBitmap(80, 24, scan_alt_right_img, 4, 24); //рисуем правую шкалу

  for (uint8_t i = 0; i < 3; i++) { //отрисовываем 3 строки
    uint8_t scale = 0; //устанавливаем столбец в ноль
    if ((r + 1) / 8 > i) scale = 8; //если столбец полный, зарисовываем полностью
    else if (r >= (i * 8 + r % 8)) scale = r % 8 + 1; //иначе отрисовываем остаток
    drawBitmap(p, 40 - i * 8, (uint8_t*)pgm_read_word(&scan_scale[scale]), 1, 8); //отрисовка
  }
#else
  if (r > 15)r = 15; //ограничивываем максимум
  if (p == 4) drawBitmap(0, 32, scan_left_img, 4, 16); //рисуем левую шкалу
  if (p == 79) drawBitmap(80, 32, scan_right_img, 4, 16); //рисуем правую шкалу

  for (uint8_t i = 0; i < 2; i++) { //отрисовываем 2 строки
    uint8_t scale = 0; //устанавливаем столбец в ноль
    if ((r + 1) / 8 > i) scale = 8; //если столбец полный, зарисовываем полностью
    else if (r >= (i * 8 + r % 8)) scale = r % 8 + 1; //иначе отрисовываем остаток
    drawBitmap(p, 40 - i * 8, (uint8_t*)pgm_read_word(&scan_scale[scale]), 1, 8); //отрисовка
  }
#endif
}
//-----------------------------------Параметры-----------------------------------------
void parameters(void) //параметры
{
  uint8_t time_out = 0; //счетчик авто-выхода

  sthv = 1; //разрешаем проверку скорости
  scr = 0; //разрешаем обновление экрана

  while (1) {
    error_messege(); //обработка ошибок
    alarm_warning(); //если фон превышен и тревога не запрещена, выводим сообщение
    pump(); //накачка по обратной связи с АЦП
    low_pwr(); //уход в сон для экономии энергии
    data_convert(); //преобразование данных

    if (!scr) {
      scr = 1; //запрещаем обновление экрана

#if TIME_OUT_PARAM
      if (++time_out > TIME_OUT_PARAM) {
        sthv = 0; //запрещаем проверку скорости
        scr = 0; //разрешаем обновления экрана
        return;
      }
#endif

      uint8_t vcc_adc = VCC_read(); //считываем значение акб
      float vcc_bat = (opornoe * 255.0) / vcc_adc; //состояние батареи
      uint16_t vcc_hv = hv_adc * opornoe * k_delitel / 255; //считем высокое перед выводом

      clrScr(); //очистка экрана
      setFont(RusFont); //установка шрифта
      drawBitmap(0, 0, stat_img, 84, 8); //устанавлваем фон

      print("<fnfhtz&", LEFT, 8);
      printNumF(vcc_bat, 2, RIGHT, 8, 46, 4, 48); //напряжение акб
      print("Pyfx.FWG&", LEFT, 16);
      printNumI(vcc_adc, RIGHT, 16); //значение ацп акб

      print("Yfrfxrf&", LEFT, 24); //напряжение высокого и скорость накачки
      printNumI(vcc_hv, RIGHT, 24);
      print("Crjhjcnm&", LEFT, 32); //напряжение высокого и скорость накачки
      printNumI(speed_nak, RIGHT, 32);

      print("Jgjhyjt&", LEFT, 40); //напряжение высокого и скорость накачки
      printNumF(opornoe, 2, RIGHT, 40, 46, 4, 48);

      speed_nak = 0; //сбрасываем скорость накачки
    }

    switch (check_keys()) {
      case 2: //Down key
      case 3: //Up key
      case 5: //select key
        time_out = 0; //сбрасывает авто-выход
        break;

      case 6: //hold select key //выход
        sthv = 0; //запрещаем проверку скорости
        scr = 0; //разрешаем обновление экрана
        return;
    }
  }
}
//-----------------------------------Отладка---------------------------------
void debug(void) //отладка
{
  uint8_t time_out = 0;
  uint8_t n = 0; //курсор
  sthv = 1; //разрешаем проверку скорости
  scr = 0; //разрешаем обновление экрана

  while (1) {
    pump(); //накачка по обратной связи с АЦП
    low_pwr(); //отключение дисплея и подсветки, уход в сон для экономии энергии
    data_convert(); //преобразование данных

    if (!scr) {
      scr = 1; //запрещаем обновление экрана

#if TIME_OUT_DEBUG
      if (++time_out > TIME_OUT_DEBUG) {
        error = 0; //сбрасываем указатель ошибки
        sthv = 0; //запрещаем проверку скорости
        scr = 0; //разрешаем обновления экрана
        return;
      }
#endif

      clrScr(); //очистка экрана
      setFont(RusFont); //установка шрифта
      drawBitmap(0, 0, debug_img, 84, 8); //устанавлваем фон

      uint8_t vcc_adc = VCC_read(); //читаем состояние батареи
      float vcc_bat = (opornoe * 255.0) / vcc_adc; //состояние батареи
      uint16_t vcc_hv = hv_adc * opornoe * k_delitel / 255; //считем высокое перед выводом

      print("Gthbjl&", LEFT, 8); //Период:
      printNumI(wdt_period, RIGHT, 8); //переод тика ВДТ
      print("<FN", LEFT, 16); //БАТ
      printNumF(vcc_bat, 2, 20, 16, 46, 4, 48); //напряжение акб
      print("FWG", 46, 16); //АЦП
      printNumI(vcc_adc, RIGHT, 16); //значение ацп акб
      print("DD", 0, 24); //ВВ
      printNumI(vcc_hv, 18, 24); //напряжение высокого
      print("CRH", 46, 24); //СКР
      printNumI(speed_nak, RIGHT, 24); //скорость накачки

      speed_nak = 0; //сбрасываем скорость накачки

      for (uint8_t i = 0; i < 8; i++) {
        if (n == i) invertText(true); //включаем инверсию
        switch (i) {
          case 0: print("JGH", LEFT, 32); break; //ОПР
          case 1: print("BVG", LEFT, 40); break; //ИМП
          case 2: print("RLK", 46, 32); break; //КДЛ
          case 3: print("FWG", 46, 40); break; //АЦП
          case 4: printNumF(opornoe, 2, 20, 32, 46, 4, 48); break; //опорное напряжение
          case 5: printNumI(puls, 20, 40); break; //длинна импульса
          case 6: printNumI(k_delitel, RIGHT, 32); break; //коэффициент делителя
          case 7: printNumI(ADC_value, RIGHT, 40); break; //значение АЦП для преобразователя
        }
        if (n == i) invertText(false); //выключаем инверсию
      }
    }

    switch (check_keys()) {

      case 3: //Up key //нажатие
        switch (n) {
          case 0: if ((opornoe += 0.01) > 1.50) opornoe = 1.50; break; //прибавляем опорное напряжение
          case 1: if (++puls > 30) puls = 30; break; //прибавляем длинну импульса
          case 2: if (++k_delitel > 999) k_delitel = 999; break; //прибавляем коэффициент делителя
          case 3: if (++ADC_value > 254) ADC_value = 254; break; //прибавляем значение АЦП для преобразователя
        }
        time_out = 0; //сбрасывает авто-выход
        scr = 0; //разрешаем обновление экрана
        break;

      case 2: //Down key //нажатие
        switch (n) {
          case 0: if ((opornoe -= 0.01) < 0.50) opornoe = 0.50; break; //убавляем опорное напряжение
          case 1: if (--puls < 1) puls = 1; break; //убавляем длинну импульса
          case 2: if (--k_delitel < 10) k_delitel = 10; break; //убавляем коэффициент делителя
          case 3: if (--ADC_value < 10) ADC_value = 10; break; //убавляем значение АЦП для преобразователя
        }
        time_out = 0; //сбрасывает авто-выход
        scr = 0; //разрешаем обновление экрана
        break;

      case 5: //select key //нажатие
        if (++n > 3) n = 0;
        time_out = 0; //сбрасывает авто-выход
        scr = 0; //разрешаем обновление экрана
        break;

      case 6: //hold select key ///выход в настройки
        pump_update(); //обновление настроек преобразователя
        error = 0; //сбрасываем указатель ошибки
        sthv = 0; //запрещаем проверку скорости
        scr = 0; //разрешаем обновление экрана
        return;
    }
  }
}
//------------------------------------Отрисовка пунктов------------------------------------------------------
void _setings_item_switch(boolean set, boolean inv, uint8_t num, uint8_t pos) //отрисовка пунктов
{
  uint8_t pos_row = pos * 8 + 16; //переводим позицию в номер строки

  if (inv) invertText(true); //включаем инверсию

  switch (num) {
    case 0: //Вспышки
      switch (set) {
        case 0: print("Dcgsirb&", LEFT, pos_row); break; //Вспышки:
        case 1: if (!rad_flash) print("DSRK", RIGHT, pos_row); else if (rad_flash == 2) print("RH.CYF", RIGHT, pos_row); else print("DRK", RIGHT, pos_row); break;
      }
      break;

    case 1: //Контраст
      switch (set) {
        case 0: print("Rjynhfcn&", LEFT, pos_row); break; //Контраст:
        case 1: printNumI(contrast, RIGHT, pos_row); break;
      }
      break;

    case 2: //Сон
      switch (set) {
        case 0: print("Cjy&", LEFT, pos_row); break; //Сон:
        case 1: if (sleep_switch < 2) print("DSRK", RIGHT, pos_row); else printNumI(TIME_SLEEP, RIGHT, pos_row); break;
      }
      break;

    case 3: //Подсветка
      switch (set) {
        case 0: print("Gjlcdtnrf&", LEFT, pos_row); break; //Подсветка:
        case 1: if (!sleep_switch) print("HEXY", RIGHT, pos_row); else printNumI(TIME_BRIGHT, RIGHT, pos_row); break;
      }
      break;
    case 4: //Щелчки
      switch (set) {
        case 0: print("Otkxrb&", LEFT, pos_row); break; //Щелчки:
        case 1: if (!buzz_switch) print("DSRK", RIGHT, pos_row); else if (buzz_switch == 1) print("DRK", RIGHT, pos_row); else print("AJY1", RIGHT, pos_row); break;
      }
      break;

    case 5: //Зв.Кнопок
      switch (set) {
        case 0: print("Pd.Ryjgjr&", LEFT, pos_row); break; //Зв.Кнопок:
        case 1: if (knock_disable) print("DSRK", RIGHT, pos_row); else print("DRK", RIGHT, pos_row); break;
      }
      break;

    case 6: //Счёт
      switch (set) {
        case 0: print("Cxtn&", LEFT, pos_row); break; //Счёт:
        case 1: printNumI(GEIGER_TIME, RIGHT, pos_row); break;
      }
      break;

    case 7: //Разн.зам
      switch (set) {
        case 0: print("Hfpy.pfv&", LEFT, pos_row); break; //Разн.зам:
        case 1: printNumI(diff_measuring[pos_measur], RIGHT, pos_row); break;
      }
      break;

    case 8: //Средн.зам
      switch (set) {
        case 0: print("Chtly.pfv&", LEFT, pos_row); break; //Средн.зам:
        case 1: printNumI(mid_rad_time[mid_level], RIGHT, pos_row); break;
      }
      break;

    case 9: //Ед.измер
      switch (set) {
        case 0: print("Tl.bpvth&", LEFT, pos_row); break; //Ед.измер:
        case 1: if (!rad_mode) print("vrH", RIGHT, pos_row); else print("vrPd", RIGHT, pos_row); break;
      }
      break;

    case 10: //Тревога Ф
      switch (set) {
        case 0: print("Nhtdjuf A&", LEFT, pos_row); break; //Тревога Ф:
        case 1: if (alarm_back_disable) print("DSRK", RIGHT, pos_row); else if (alarm_back_sound_disable) print("DB<H", RIGHT, pos_row); else print("D+PD", RIGHT, pos_row); break;
      }
      break;

    case 11: //Порог Ф1
      switch (set) {
        case 0: print("Gjhju A1&", LEFT, pos_row); break; //Порог Ф1:
        case 1: printNumI(warn_level_back, RIGHT, pos_row); break;
      }
      break;

    case 12: //Порог Ф2
      switch (set) {
        case 0: print("Gjhju A2&", LEFT, pos_row); break; //Порог Ф2:
        case 1: printNumI(alarm_level_back, RIGHT, pos_row); break;
      }
      break;

    case 13: //Тревога Д
      switch (set) {
        case 0: print("Nhtdjuf L&", LEFT, pos_row); break; //Тревога Д:
        case 1: if (alarm_dose_disable) print("DSRK", RIGHT, pos_row); else if (alarm_dose_sound_disable) print("DB<H", RIGHT, pos_row); else print("D+PD", RIGHT, pos_row); break;
      }
      break;

    case 14: //Порог Д1
      switch (set) {
        case 0: print("Gjhju L1&", LEFT, pos_row); break; //Порог Д1:
        case 1: printNumI(warn_level_dose, RIGHT, pos_row); break;
      }
      break;

    case 15: //Порог Д2
      switch (set) {
        case 0: print("Gjhju L2&", LEFT, pos_row); break; //Порог Д2:
        case 1: printNumI(alarm_level_dose, RIGHT, pos_row); break;
      }
      break;
  }
  if (inv) invertText(false); //выключаем инверсию
}
//------------------------------------Прибавление данных------------------------------------------------------
void _setings_data_up(uint8_t pos) //прибавление данных
{
  switch (pos)
  {
    case 0: switch (rad_flash) { //Вспышки
        case 0: rad_flash = 1; break;
        case 1: rad_flash = 2; break;
      }
      break;
    case 1: if (contrast < 127) contrast++; setContrast(contrast); break; //Контраст
    case 2: //Сон
      switch (sleep_switch) {
        case 0: sleep_switch = 2; LIGHT_ON; light_lcd = 1; break;
        case 1: sleep_switch = 2; TIME_BRIGHT = 5; break;
        case 2: if (TIME_SLEEP < 250) TIME_SLEEP += 5; break;
      }
      break;
    case 3: //Подсветка
      switch (sleep_switch) {
        case 0: sleep_switch = 1; LIGHT_ON; light_lcd = 1; break;
        case 1: if (TIME_BRIGHT < 250) TIME_BRIGHT += 5; break;
        case 2: if (TIME_BRIGHT < TIME_SLEEP - 5) TIME_BRIGHT += 5; break;
      }
      break;
    case 4: switch (buzz_switch) { //Щелчки
        case 0: buzz_switch = 1; break;
        case 1: buzz_switch = 2; break;
      }
      break;
    case 5: knock_disable = 0; break; //Зв.кнопок
    case 6: if (GEIGER_TIME < MAX_GEIGER_TIME) GEIGER_TIME++; break; //Счет
    case 7: if (pos_measur < 9) pos_measur++; break; //Разн.зам
    case 8: if (mid_level < 9) mid_level ++; else mid_level = 0; break; //Средн.зам
    case 9: rad_mode = 1; break; //Ед.измер
    case 10: if (alarm_back_disable) alarm_back_disable = 0; else alarm_back_sound_disable = 0; break; //Тревога Ф
    case 11: if (warn_level_back < 300) warn_level_back += 5; else warn_level_back = 30; break; //Порог Ф1
    case 12: if (alarm_level_back < 500) alarm_level_back += 10; else if (alarm_level_back < 1000) alarm_level_back += 50; else if (alarm_level_back < 65000) alarm_level_back += 100; else alarm_level_back = 300; break; //Порог Ф2
    case 13: if (alarm_dose_disable) alarm_dose_disable = 0; else alarm_dose_sound_disable = 0; break; //Тревога Д
    case 14: if (warn_level_dose < 300) warn_level_dose += 5; else warn_level_dose = 10; break; //Порог Д1
    case 15: if (alarm_level_dose < 500) alarm_level_dose += 10; else if (alarm_level_dose < 1000) alarm_level_dose += 50; else if (alarm_level_dose < 65000) alarm_level_dose += 100; else alarm_level_dose = 300; break; //Порог Д2
  }
}
//------------------------------------Убавление данных------------------------------------------------------
void _setings_data_down(uint8_t pos) //убавление данных
{
  switch (pos)
  {
    case 0: switch (rad_flash) { //Вспышки
        case 1: rad_flash = 0; break;
        case 2: rad_flash = 1; break;
      }
      break;
    case 1: if (contrast > 0) contrast--; setContrast(contrast); break; //Контраст
    case 2: if (TIME_SLEEP > 10) { //Сон
        TIME_SLEEP -= 5;
        if (TIME_BRIGHT == TIME_SLEEP) TIME_BRIGHT -= 5;
      }
      else if (sleep_switch == 2) sleep_switch = 1; break;
    case 3: if (TIME_BRIGHT > 5) TIME_BRIGHT -= 5; else sleep_switch = 0; break; //Подсветка
    case 4: switch (buzz_switch) { //Щелчки
        case 1: buzz_switch = 0; break;
        case 2: buzz_switch = 1; break;
      }
      break;
    case 5: knock_disable = 1; break; //Зв.кнопок
    case 6: if (GEIGER_TIME > MIN_GEIGER_TIME) GEIGER_TIME--; break; //Счет
    case 7: if (pos_measur > 0) pos_measur--;  break; //Разн.зам
    case 8: if (mid_level > 0) mid_level --; else mid_level = 9; break; //Средн.зам
    case 9: rad_mode = 0; break; //Ед.измер
    case 10: if (!alarm_back_sound_disable) alarm_back_sound_disable = 1; else alarm_back_disable = 1; break; //Тревога Ф
    case 11: if (warn_level_back > 30) warn_level_back -= 5; else warn_level_back = 300; break; //Порог Ф1
    case 12: if (alarm_level_back > 1000) alarm_level_back -= 100; else if (alarm_level_back > 500) alarm_level_back -= 50; else if (alarm_level_back > 300) alarm_level_back -= 10; else alarm_level_back = 65000; break; //Порог Ф2
    case 13: if (!alarm_dose_sound_disable) alarm_dose_sound_disable = 1; else alarm_dose_disable = 1; break; //Тревога Д
    case 14: if (warn_level_dose > 10) warn_level_dose -= 5; else warn_level_dose = 300; break; //Порог Д1
    case 15: if (alarm_level_dose > 1000) alarm_level_dose -= 100; else if (alarm_level_dose > 500) alarm_level_dose -= 50; else if (alarm_level_dose > 300) alarm_level_dose -= 10; else alarm_level_dose = 65000; break; //Порог Д2
  }
}
//------------------------------------Настройки------------------------------------------------------
void setings(void) //настройки
{
  uint8_t n = 0; //позиция
  uint8_t c = 0; //курсор
  uint8_t set = 0; //разрешение на настроку
  uint8_t time_out = 0; //таймер автовыхода
  scr = 0; //разрешаем обновления экрана

  while (1) {
    pump(); //накачка по обратной связи с АЦП
    low_pwr(); //уход в сон для экономии энергии
    data_convert(); //преобразование данных

    //+++++++++++++++++++   вывод информации на экран  +++++++++++++++++++++++++
    if (!scr)
    {
      scr = 1; //запрещаем обновления экрана

#if TIME_OUT_SETTINGS
      if (++time_out > TIME_OUT_SETTINGS) {
        setings_save(); //сохраняем настройки
        scr = 0; //разрешаем обновления экрана
        return;
      }
#endif

      clrScr(); // Очистка экрана
      drawBitmap(0, 0, setings_img, 84, 16); //отрисовываем фон
      setFont(RusFont); //установка шрифта

      for (uint8_t i = 0; i < 4; i++) { //отсчет строк
        for (uint8_t r = 0; r < 2; r++) { //отсчет позиции
          boolean inv = 0; //инверсия
          if (i == c) if (r == set) inv = 1; //если курсор на нужной строке
          _setings_item_switch(r, inv, n - c + i, i); //отрисовываем пункты настроек
        }
      }
    }
    //+++++++++++++++++++++  опрос кнопок  +++++++++++++++++++++++++++
    switch (check_keys())
    {
#if PARAM_RETURN
      case 1: if (!set) parameters(); break; //Down key hold //удержание вниз
#endif

      case 2: //Down key //вниз
        switch (set) {
          case 0:
            if (n < 15) { //изменяем позицию
              n++;
              if (c < 3) c++; //изменяем положение курсора
            }
            else { //иначе начало списка
              n = 0;
              c = 0;
            }
            break;
          case 1: _setings_data_down(n); break; //убавление данных
        }
        time_out = 0; //сбрасываем авто-выход
        scr = 0; //разрешаем обновления экрана
        break;

      case 3: //Up key  //вверх
        switch (set) {
          case 0:
            if (n > 0) { //изменяем позицию
              n--;
              if (c > 0) c--; //изменяем положение курсора
            }
            else { //иначе конец списка
              n = 15;
              c = 3;
            }
            break;
          case 1: _setings_data_up(n); break; //прибавление данных
        }
        time_out = 0; //сбрасываем авто-выход
        scr = 0; //разрешаем обновления экрана
        break;

#if DEBUG_RETURN
      case 4: if (!set) debug(); break; //Up key hold //удержание вверх
#endif

      case 5: //select key //выбор
        switch (set) {
          case 0: set = 1; break;
          case 1: set = 0; break;
        }
        time_out = 0; //сбрасываем авто-выход
        scr = 0; //разрешаем обновления экрана
        break;

      case 6: //hold select key //выход из настроек
        setings_save(); //сохраняем настройки
        scr = 0; //разрешаем обновления экрана
        return;
    }
  }
}
//-----------------------------------быстрое меню---------------------------------
void fast_menu(void) //быстрое меню
{
  uint8_t i = 0; //переключатель мелодии
  uint8_t time_out = 0; //счетчик тайм-аута
  uint32_t timer_sound = millis(); //таймер мелодии
  scr = 0; //разрешаем обновление экрана

  clrScr(); //очистка экрана
  setFont(RusFont); //установка шрифта

  drawBitmap(0, 0, fast_up_img, 84, 8); //устанавлваем фон
  drawBitmap(0, 40, fast_down_img, 84, 8); //устанавлваем фон
  drawBitmap(0, 8, fast_light_img, 28, 32); //устанавлваем фон
#if MESSUR_OR_PWR
  drawBitmap(28, 8, fast_power_img, 28, 32); //устанавлваем фон
#else
  drawBitmap(28, 8, fast_beta_img, 28, 32); //устанавлваем фон
#endif
  drawBitmap(56, 8, fast_flash_img, 28, 32); //устанавлваем фон

  while (1) {

    //==================================================================
#if FAST_SOUND
    if (i != SAMPLS_FAST && millis() > timer_sound) { //играем волшебную мелодию
      buzz_pulse(pgm_read_word(&fast_sound[i][0]), pgm_read_word(&fast_sound[i][1]));
      timer_sound = millis() + pgm_read_word(&fast_sound[i][2]);
      i++;
    }
#endif
    //==================================================================

    pump(); //накачка по обратной связи с АЦП
    data_convert(); //преобразование данных

#if TIME_OUT_FAST
    if (!scr) {
      scr = 1; //запрещаем обновление экрана
      if (++time_out > TIME_OUT_FAST) {
        light_update(); //сохранение подсветки
        scr = 0; //разрешаем обновления экрана
        return;
      }
    }
#endif

#if TYPE_FAST_MENU //если выбран автоматический выход
    //---------------------------//
    switch (check_keys()) {

      case 2: //Downt key
        if (!sleep_switch) { //если сон выключен
          if (light_lcd) { //выключаем подсветку
            LIGHT_OFF;
            light_lcd = 0;
          }
          else { //иначе включаем подсветку
            LIGHT_ON;
            light_lcd = 1;
          }
          light_update(); //сохранение подсветки
        }
        return;

      case 3: //Up key
#if MESSUR_OR_PWR
        power_down(); //выключение питания
#else
        measur_menu(); //режим разностного замера(бета)
#endif
        scr = 0; //разрешаем обновления экрана
        return;

      case 4: //Up key hold
        return;

      case 5: //select key
        if (is_FLASH_ON) FLASH_OFF;
        else FLASH_ON;
        return;
    }
    //---------------------------//
#else //иначе выход только в ручную
    //---------------------------//
    switch (check_keys()) {

      case 2: //Downt key
        if (!sleep_switch) {
          if (light_lcd) {
            LIGHT_OFF;
            light_lcd = 0;
          }
          else {
            LIGHT_ON;
            light_lcd = 1;
          }
        }
        scr = 0; //разрешаем обновления экрана
        time_out = 0; //сбрасывает авто-выход
        break;

      case 3: //Up key
#if MESSUR_OR_PWR
        power_down(); //выключение питания
#else
        measur_menu(); //режим разностного замера(бета)
#endif
        scr = 0; //разрешаем обновления экрана
        time_out = 0; //сбрасывает авто-выход
        break;

      case 4: //Up key hold
        light_update(); //сохранение подсветки
        return;

      case 5: //select key
        if (is_FLASH_ON) FLASH_OFF;
        else FLASH_ON;
        time_out = 0; //сбрасывает авто-выход
        scr = 0; //разрешаем обновления экрана
        break;
    }
    //---------------------------//
#endif
  }
}
//---------------------------------Сообщение об ошибке---------------------------------------
void error_messege(void) //сообщение об ошибке
{
  boolean i = 0; //переключатель мелодии
  uint32_t timer_sound = millis(); //таймер мелодии
  static uint32_t time_out; //тайм-аут ошибки

  if (error && time_out < time_sec) { //если время вышло, выводим ошибку

    cnt_pwr = 0; //обнуляем счетчик
    low_pwr(); //просыпаемся если спали

    buzz_switch = 0; //запрещаем щелчки

    clrScr(); //очистка экрана
    setFont(RusFont); //установка шрифта

    invertText(true);
    print(" JIB<RF! ", CENTER, 0); //ОШИБКА!
    invertText(false);

    switch (error) {
      case 1:
        print("C,jq hf,jns", CENTER, 16); //Сбой работы
        print("nfqvthf!", CENTER, 24); //таймера!
        break;

      case 2:
        print("Gthtuheprf", CENTER, 16); //Перегрузка
        print("ghtj,hfpjdfn!", CENTER, 24); //преобразоват!
        print("FWG&", 18, 32); //АЦП:
        printNumI(hv_adc, 43, 32);
        break;

      case 3:
        print("Rjhjnrjt pfv.", CENTER, 16); //Короткое зам.
        print("ghtj,hfpjdfn!", CENTER, 24); //преобразователя!
        print("FWG&", 18, 32); //АЦП:
        printNumI(hv_adc, 43, 32);
        break;

      case 4:
        print("Ytn cxtnf!", CENTER, 24); //Нет счета!
        break;
    }

    for (uint32_t t = millis() + ERROR_MASSEGE_TIME; t > millis();) { //ждем
      pump(); //накачка по обратной связи с АЦП
      data_convert(); //преобразование данных

      //==================================================================
      _melody_chart(error_sound, SAMPLS_ERROR, 5); //играем волшебную мелодию
      //==================================================================

      if (check_keys()) break;
    }
    error = 0; //сбрасываем указатель ошибки
    buzz_read(); //считываем настроку щелчков
    time_out = time_sec + ERROR_LENGTHY_TIME; //добавляем n сек. до следущего сообщения
    clrScr(); //очистка экрана
    scr = 0; //разрешаем обновления экрана
  }
}
//---------------------------------Калибровка wdt---------------------------------------
void wdt_calibrate(void) //калибровка wdt
{
  InitLCD();
  setFont(RusFont); //установка шрифта
  print("Gj;fkeqcnf", CENTER, 16); //Пожалуйста
  print("gjlj;lbnt...", CENTER, 24); //подождите...
  for (uint32_t t = millis() + MASSEGE_TIME; t > millis();); //ждем

  uint32_t timeout = millis() + WDT_TIMEOUT; //тайм-аут калибровки таймера

  while (wdt_period < 1600 || wdt_period > 1850) {
    WDTCSR |= (1 << WDCE) | (1 << WDE); //разрешаем вмешательство
    WDTCSR = 0x40; //таймаут ~ 17 мc
    asm ("wdr"); //сбросили пса
    uint32_t startTime = micros(); //засекли время
    while (!(WDTCSR & (1 << WDIF))); //ждем таймаута
    wdt_period = ((micros() - startTime) / 10) + TIME_CORRECT; //вычисляем время с коррекцией
    WDTCSR |= (1 << WDCE) | (1 << WDE); //разрешаем вмешательство
    WDTCSR = 0; //выключаем собаку

    if (millis() > timeout) {
#if ERRORS_RETURN
      error = 1; //устанавливаем ошибку 1
#endif
      wdt_period = 1750;
      return;
    }
  }
  eeprom_update_word(110, wdt_period);
  clrScr(); // Очистка экрана
}
//------------------------------------Чтение настроек----------------------------------------------
void setings_read(void) //чтение настроек
{
  light_lcd = eeprom_read_byte(40);
  contrast = eeprom_read_byte(41);
  mid_level = eeprom_read_byte(42);
  alarm_back_disable = eeprom_read_byte(43);
  buzz_switch = eeprom_read_byte(44);
  knock_disable = eeprom_read_byte(45);
  pos_measur = eeprom_read_byte(46);
  alarm_dose_disable = eeprom_read_byte(47);
  sleep_switch = eeprom_read_byte(48);
  TIME_BRIGHT = eeprom_read_byte(49);
  TIME_SLEEP = eeprom_read_byte(50);
  GEIGER_TIME = eeprom_read_byte(51);
  rad_mode = eeprom_read_byte(57);
  alarm_back_sound_disable = eeprom_read_byte(58);
  rad_flash = eeprom_read_byte(59);
  alarm_dose_sound_disable = eeprom_read_byte(61);
  warn_level_back = eeprom_read_word(62);
  alarm_level_back = eeprom_read_word(64);
  warn_level_dose = eeprom_read_word(66);
  alarm_level_dose = eeprom_read_word(68);
  wdt_period = eeprom_read_word(110);
}
//---------------------------------------Чтение статистики--------------------------------------------------
void statistic_read(void) //чтение статистики
{
  time_save = eeprom_read_dword(114);
  rad_dose_save = eeprom_read_dword(118);
}
//--------------------------------Чтение настроек преобразователя-------------------------------------------
void pump_read(void) //чтение настроек преобразователя
{
  puls = eeprom_read_byte(52);
  opornoe = eeprom_read_float(53);
  ADC_value = eeprom_read_byte(102);
  k_delitel = eeprom_read_word(104);
}
//------------------------------------Чтение состояния щелчков----------------------------------------------
void buzz_read(void) //чтение состояния щелчков
{
  buzz_switch = eeprom_read_byte(44);
}
//------------------------------------Чтение состояния вспышек----------------------------------------------
void rad_flash_read(void) //чтение состояния вспышек
{
  rad_flash = eeprom_read_byte(59);
}
//-----------------------------Обновление настроек преобразователя------------------------------------------
void pump_update(void) //обновление настроек преобразователя
{
  eeprom_update_byte(52, puls);
  eeprom_update_float(53, opornoe);
  eeprom_update_byte(102, ADC_value);
  eeprom_update_float(104, k_delitel);
}
//--------------------------------Обновление состояния подсветки--------------------------------------------
void light_update(void) //обновление состояния подсветки
{
  eeprom_update_byte(40, light_lcd);
}
//--------------------------------------Обновление статистики-----------------------------------------------
void statistic_update(void) //обновление статистики
{
  eeprom_update_dword(114, time_save);
  eeprom_update_dword(118, rad_dose_save);
}
//---------------------------------------Обновление настроек------------------------------------------------
void setings_update(void) //обновление настроек
{
  eeprom_update_byte(40, light_lcd);
  eeprom_update_byte(41, contrast);
  eeprom_update_byte(42, mid_level);
  eeprom_update_byte(43, alarm_back_disable);
  eeprom_update_byte(44, buzz_switch);
  eeprom_update_byte(45, knock_disable);
  eeprom_update_byte(46, pos_measur);
  eeprom_update_byte(47, alarm_dose_disable);
  eeprom_update_byte(48, sleep_switch);
  eeprom_update_byte(49, TIME_BRIGHT);
  eeprom_update_byte(50, TIME_SLEEP);
  eeprom_update_byte(51, GEIGER_TIME);
  eeprom_update_byte(57, rad_mode);
  eeprom_update_byte(58, alarm_back_sound_disable);
  eeprom_update_byte(59, rad_flash);
  eeprom_update_byte(61, alarm_dose_sound_disable);
  eeprom_update_word(62, warn_level_back);
  eeprom_update_word(64, alarm_level_back);
  eeprom_update_word(66, warn_level_dose);
  eeprom_update_word(68, alarm_level_dose);
}
//---------------------------------------Сброс текущей дозы--------------------------------------------
void dose_reset(void) //сброс текущей дозы
{
  uint8_t time_out = 0; //счетчик тайм-аута
  uint8_t n = 0; //курсор

  clrScr(); //очистка экрана
  setFont(RusFont); //установка шрифта
  switch (dose_mode) {
    case 0: //текущая доза
      print("C,hjcbnm", CENTER, 8); //Сбросить
      print("ntreoe/ ljpe?", CENTER, 16); //текущщую дозу?
      break;

    case 1: //накопленная доза
      print("C,hjcbnm", CENTER, 8); //Сбросить
      print("j,oe/ ljpe?", CENTER, 16); //общую дозу?
      break;
  }

  while (1) {
    pump(); //накачка по обратной связи с АЦП
    low_pwr(); //отключение дисплея и подсветки, уход в сон для экономии энергии
    data_convert(); //преобразование данных

#if TIME_OUT_DOSE
    if (!scr) {
      scr = 1; //запрещаем обновление экрана
      if (++time_out > TIME_OUT_DOSE) {
        scr = 0; //разрешаем обновления экрана
        return;
      }
    }
#endif

    choice_menu(n); //меню выбора

    switch (check_keys()) {

      case 2: //Down key
        if (n > 0) n--;
        time_out = 0; //сбрасывает авто-выход
        scr = 0; //разрешаем обновления экрана
        break;
      case 3: //Up key
        if (n < 1) n++;
        time_out = 0; //сбрасывает авто-выход
        scr = 0; //разрешаем обновления экрана
        break;

      case 5: //select key
        switch (n) {
          case 1:
            switch (dose_mode) {
              case 0: //текущая доза
                rad_dose_save += rad_dose - rad_dose_old;
                rad_sum = 0;
                rad_dose = 0;
                rad_dose_old = 0;

                time_save += time_sec - time_save_old;
                time_save_old = 0;
                time_micros = 0;
                time_sec = 0;

                stat_upd_tmr = 0;

                alarm_dose_wait = 0;
                warn_dose_wait = 0;

                clrScr(); //очистка экрана
                setFont(RusFont); //установка шрифта
                print("Ntreofz ljpf", CENTER, 16); //Текущая доза
                print("c,hjityf!", CENTER, 24); //сброшена!
                for (uint32_t t = millis() + MASSEGE_TIME; t > millis() && !check_keys();) {
                  pump(); //накачка по обратной связи с АЦП
                  data_convert(); //преобразование данных
                }
                break;

              case 1: //накопленная доза
                time_save = 0;
                rad_dose_save = 0;
                statistic_update(); //обновление статистики
                rad_dose_old = rad_dose;
                clrScr(); //очистка экрана
                setFont(RusFont); //установка шрифта
                print("Cnfnbcnbrf", CENTER, 16); //Статистика
                print("c,hjityf!", CENTER, 24); //сброшена!
                for (uint32_t t = millis() + MASSEGE_TIME; t > millis() && !check_keys();) {
                  pump(); //накачка по обратной связи с АЦП
                  data_convert(); //преобразование данных
                }
                break;
            }
            return;

          case 0:
            return;
        }
        break;
    }
  }
}
//---------------------------------------Сохранить настройки--------------------------------------------
void setings_save(void) //сохранить настройки
{
  uint8_t n = 0; //курсор

  if (
    light_lcd == eeprom_read_byte(40) &&
    contrast == eeprom_read_byte(41) &&
    mid_level == eeprom_read_byte(42) &&
    alarm_back_disable == eeprom_read_byte(43) &&
    buzz_switch == eeprom_read_byte(44) &&
    knock_disable == eeprom_read_byte(45) &&
    pos_measur == eeprom_read_byte(46) &&
    alarm_dose_disable == eeprom_read_byte(47) &&
    sleep_switch == eeprom_read_byte(48) &&
    TIME_BRIGHT == eeprom_read_byte(49) &&
    TIME_SLEEP == eeprom_read_byte(50) &&
    GEIGER_TIME == eeprom_read_byte(51) &&
    rad_mode == eeprom_read_byte(57) &&
    alarm_back_sound_disable == eeprom_read_byte(58) &&
    rad_flash == eeprom_read_byte(59) &&
    alarm_dose_sound_disable == eeprom_read_byte(61) &&
    warn_level_back == eeprom_read_word(62) &&
    alarm_level_back == eeprom_read_word(64) &&
    warn_level_dose == eeprom_read_word(66) &&
    alarm_level_dose == eeprom_read_word(68)
  )
    return;

  else {
    uint8_t time_out = 0; //таймер автовыхода

    clrScr(); //очистка экрана
    setFont(RusFont); //установка шрифта
    print("Cj[hfybnm", CENTER, 8); //Сохранить
    print("yfcnhjqrb?", CENTER, 16); //настройки?

    while (1) {
      pump(); //накачка по обратной связи с АЦП
      low_pwr(); //отключение дисплея и подсветки, уход в сон для экономии энергии
      data_convert(); //преобразование данных

#if TIME_OUT_SETTINGS
      if (!scr) {
        scr = 1; //сбрасываем флаг
        if (++time_out > TIME_OUT_SETTINGS) {
          setings_read(); //считываем настройки из памяти
          return;
        }
      }
#endif

      choice_menu(n); //меню выбора

      switch (check_keys()) {

        case 2: //Down key
          if (n > 0) n--;
          time_out = 0; //сбрасывает авто-выход
          scr = 0; //разрешаем обновления экрана
          break;
        case 3: //Up key
          if (n < 1) n++;
          time_out = 0; //сбрасывает авто-выход
          scr = 0; //разрешаем обновления экрана
          break;

        case 5: //select key
          switch (n) {
            case 1:
              setings_update(); //обновляем настройки
              clrScr(); //очистка экрана
              print("Yfcnhjqrb", CENTER, 16); //Настройки
              print("Cj[hfytys!", CENTER, 24); //Сохранены!
              for (uint32_t t = millis() + MASSEGE_TIME; t > millis() && !check_keys();) {
                pump(); //накачка по обратной связи с АЦП
                data_convert(); //преобразование данных
              }
              scr = 0; //разрешаем обновления экрана
              return;

            case 0:
              setings_read(); //считываем настройки из памяти
              scr = 0; //разрешаем обновления экрана
              return;
          }
          break;
      }
    }
  }
}
//---------------------------------------Меню выбора--------------------------------------------
void choice_menu(boolean n) //меню выбора
{
  for (uint8_t i = 0; i < 2; i++) { //отрисовка пунктов
    if (n == i) invertText(true); //включаем инверсию
    switch (i) {
      case 0: print("  ytn  ", LEFT, 32); break; //нет
      case 1: print("  lf  ", RIGHT, 32); break; //да
    }
    if (n == i) invertText(false); //выключаем инверсию
  }
}
// -----------------------------Отрисовка линий точности---------------------------------------
void _screen_line(uint8_t up_bar, uint8_t down_bar, boolean rent_bar, uint8_t start_bar, uint8_t pos_bar) //отрисовка линий
{
  for (uint8_t i = 0; i < down_bar; i++) {
    drawBitmap(i + start_bar, pos_bar, (uint8_t*)pgm_read_word(&_scale[rent_bar]), 1, 8); //шкала готовности общая
  }
  for (uint8_t i = down_bar; i < up_bar; i++) {
    drawBitmap(i + start_bar, pos_bar, (uint8_t*)pgm_read_word(&_scale[2]), 1, 8); //шкала готовности верхняя
  }
}
//----------------------------------Шапка экрана------------------------------------------------
void task_bar(void) //шапка экрана
{
  drawBitmap(0, 0, font_alt_img, 84, 8); //устанавлваем фон
  drawBitmap(70, 0, bat_alt_img, bat * 2, 8); //отображаем состояние батареи

  if (alarm_back_disable) //если тревога запрещена
  {
    if (alarm_back_wait) drawBitmap(60, 0, beep_alt_waint_img, 7, 8); //если ждем понижения фона
    else drawBitmap(60, 0, beep_alt_off_img, 7, 8); //иначе тревога выключена
  }
  else if (alarm_back_sound_disable) drawBitmap(60, 0, beep_alt_vibro_img, 7, 8); //иначе если звук выключен
  else drawBitmap(60, 0, beep_alt_img, 8, 8);

  if (buzz_switch && !knock_disable) drawBitmap(47, 0, buzz_alt_on_img, 7, 8); //если щелчки и зв.кнопок включен
  else if (buzz_switch) drawBitmap(47, 0, buzz_alt_img, 7, 8); //если щелчки включены и зв.кнопок выключен
  else if (!knock_disable) drawBitmap(47, 0, beep_alt_waint_img, 7, 8); //если щелчки выключены и зв.кнопок включен
  else drawBitmap(47, 0, buzz_alt_off_img, 7, 8); //иначе выключено все

  switch (scr_mode)
  {
    case 0: drawBitmap(0, 0, backgr_img, 17, 8); break;  //режим текущего фона
    case 1: drawBitmap(0, 0, dose_img, 22, 8); break;  //режим накопленной дозы
#if SEARCH_RETURN
    case 2: drawBitmap(0, 0, serch_img, 26, 8); break;  //режим поиска
#endif
  }
#if COEF_DEBUG //отладка коэффициента
  switch (scr_mode)
  {
    case 0: setFont(TinyNumbersUp); //установка шрифта
      invertText(true);
      printNumF(now, 2, 19, 0, 46, 5, 43); //строка 1
      invertText(false);
      printNumF(debug_coef, 2, 57, 8, 46, 5, 43); //строка 2
      break;
  }
#endif
}
//----------------------------------Инициализация значений большим шрифтом------------------------------------------------------
void init_rads_unit(boolean smb, uint32_t num, uint8_t divisor, uint8_t char_all, uint8_t num_x, uint8_t num_y, boolean unit, uint8_t unit_x, uint8_t unit_y) //инициализация значений большим шрифтом
{
  uint8_t _ptr;
  
  if (rad_mode) _ptr = PATERNS_SVH;
  else _ptr = PATERNS_RH;
  
  if (smb) setFont(MediumNumbers); //установка шрифта
  else setFont(RusFont); //установка шрифта

  for (uint8_t i = 0; i < _ptr; i++) {
    if (num < pgm_read_dword(&patern_all[rad_mode][i][0]) * divisor) {
      if (smb) printNumF(float(num) / pgm_read_dword(&patern_all[rad_mode][i][2]), pgm_read_dword(&patern_all[rad_mode][i][1]), num_x, num_y, 46, char_all, TYPE_CHAR_FILL); //строка 1
#if (TYPE_CHAR_FILL > 44)
      else printNumF(float(num) / pgm_read_dword(&patern_all[rad_mode][i][2]), pgm_read_dword(&patern_all[rad_mode][i][1]), num_x, num_y, 46, char_all, TYPE_CHAR_FILL); //строка 1
#else
      else printNumF(float(num) / pgm_read_dword(&patern_all[rad_mode][i][2]), pgm_read_dword(&patern_all[rad_mode][i][1]), num_x, num_y, 46, char_all, 32); //строка 1
#endif
      rads_unit(pgm_read_dword(&patern_all[rad_mode][i][3]), unit, unit_x, unit_y); //устанавливаем единицы измерения
      break;
    }
  }
}
//----------------------------------Единицы измерения------------------------------------------------------
void rads_unit(boolean set, boolean unit, uint8_t unit_x, uint8_t unit_y) //Единицы измерения
{
  setFont(RusFont); //установка шрифта
  switch (rad_mode)
  {
    case 0:
      //мкР
      switch (set) {
        case 0:
          switch (unit) {
            case 0: print("vrH|x", unit_x, unit_y); break; //строка 2 мкР/ч
            case 1: print("vrH", unit_x, unit_y); break; //строка 2 мкР
          }
          break;

        case 1:
          switch (unit) {
            case 0: print("vH|x", unit_x, unit_y); break; //строка 2 мР/ч
            case 1: print("vH", unit_x, unit_y); break; //строка 2 мР
          }
          break;
      }
      break;

    case 1:
      //мкЗв
      switch (set) {
        case 0:
          switch (unit) {
            case 0: print("vrP|x", unit_x, unit_y); break; //строка 2 мкЗ/ч
            case 1: print("vrP", unit_x, unit_y); break; //строка 2 мкЗ
          }
          break;

        case 1:
          switch (unit) {
            case 0: print("vP|x", unit_x, unit_y); break; //строка 2 мЗ/ч
            case 1: print("vP", unit_x, unit_y); break; //строка 2 мЗ
          }
          break;
      }
      break;
  }
}
//----------------------------------Главные экраны------------------------------------------------------
void main_screen(void)
{
  static boolean i; //анимация оповещения
#if !SEARCH_RETURN
  static boolean f; //переключатель режима фон
#endif

  //+++++++++++++++++++   вывод информации на экран  +++++++++++++++++++++++++
  if (!scr) //обновление дисплея
  {
    scr = 1; //сброс флага

    if (scr_mode != 2) clrScr(); //очистка экрана
#if SEARCH_RETURN
    else {
      clrRow(0); //очистка строки 0
      clrRow(1); //очистка строки 1
      clrRow(2); //очистка строки 2
    }
#endif

    task_bar(); //рисуем шапку экрана

    //---------------------------------------------------------------------------------------//
    switch (scr_mode)
    {
      case 0: //режим измерения текущего фона

        switch (alarm_switch) {
          case 0: _screen_line(map(constrain(geiger_time_now, 0, GEIGER_TIME), 0, GEIGER_TIME, 5, 82), map(constrain(geiger_time_now, 0, MAX_GEIGER_TIME), 0, MAX_GEIGER_TIME, 5, 82), 1, 1, 24); break; //шкалы точности и усреднения
          case 3:
            switch (i) {
              case 0: drawBitmap(18, 24, warning_img, 48, 8); i = 1; break;
              case 1: drawBitmap(17, 24, warning_inv_img, 50, 8); i = 0; break;
            }
            break;
        }

#if SEARCH_RETURN //если выбран режим поиска
        setFont(RusFont); //установка шрифта
        drawBitmap(0, 32, dose_mid_img, 26, 8);       //строка 2 сред.
        drawBitmap(0, 40, dose_max_img, 26, 8);       //строка 3 макс.

        init_rads_unit(0, rad_mid, 1, 4, 29, 32, 0, 54, 32); //строка 2 средний
        if (!first_mid) print("----", 29, 32); //если первый средний замер не готов

        init_rads_unit(0, rad_max, 1, 4, 29, 40, 0, 54, 40); //строка 3 максимальный
#else //иначе отрисовываем график в режиме фон
        switch (f) {
          case 0:
#if TYPE_GRAF_MOVE //слева-направо
            for (uint8_t i = 4; i < 80; i++) {
              graf_lcd(map(graf_buff[i - 4], 0, maxLevel, 0, 15), i); //инициализируем график
            }
#else //справа-налево
            for (uint8_t i = 79; i > 3; i--) {
              graf_lcd(map(graf_buff[i - 4], 0, maxLevel, 0, 15), i); //инициализируем график
            }
#endif
            break;

          case 1: //максимальный и средний фон
            setFont(RusFont); //установка шрифта
            drawBitmap(0, 32, dose_mid_img, 26, 8);       //строка 2 сред.
            drawBitmap(0, 40, dose_max_img, 26, 8);       //строка 3 макс.

            init_rads_unit(0, rad_mid, 1, 4, 29, 32, 0, 54, 32); //строка 2 средний
            if (!first_mid) print("----", 29, 32); //если первый средний замер не готов

            init_rads_unit(0, rad_max, 1, 4, 29, 40, 0, 54, 40); //строка 3 максимальный
            break;
        }
#endif

        init_rads_unit(1, rad_back, 1, 4, 1, 8, 0, 54, 16); //строка 1 основной фон

        break;
      //---------------------------------------------------------------------------------------//
      case 1: //режим накопленной дозы

        switch (dose_mode)
        {
          case 0: //текущая доза
            setFont(TinyNumbersDown); //установка шрифта
            printNumI(time_sec / 60 / 60 / 24, 34, 24, 2, 48); //дней
            drawBitmap(42, 24, day_img, 8, 8); //дн
            printNumI((time_sec / 60 / 60) % 24, 54, 24, 2, 48); //часов
            drawBitmap(62, 24, colon_img, 3, 8); //ч
            printNumI((time_sec / 60) % 60, 65, 24, 2, 48); //минут
            drawBitmap(73, 24, colon_img, 5, 8); //м
            printNumI(time_sec % 60, 76, 24, 2, 48); //секунд

            switch (alarm_switch) {
              case 0: _screen_line(0, map(stat_upd_tmr, 0, STAT_UPD_TIME, 5, 82), 1, 1, 32); break; //шкала времени до сохранения дозы
              case 4:
                switch (i) {
                  case 0: drawBitmap(18, 32, warning_img, 48, 8); i = 1; break;
                  case 1: drawBitmap(17, 32, warning_inv_img, 50, 8); i = 0; break;
                }
                break;
            }

            init_rads_unit(1, rad_dose, 10, 5, 1, 8, 1, 62, 16); //строка 1 текущая доза
            drawBitmap(0, 40, dose_all_img, 24, 8);       //строка 2 всего
            init_rads_unit(0, rad_dose_save, 10, 5, 32, 40, 1, 66, 40); //строка 2 сохранённая доза
            break;

          case 1: //общая накопленная доза и время

            printNumI(time_save / 60 / 60 / 24, 8, 40, 2, 48);
            print("l", 20, 40);
            printNumI((time_save / 60 / 60) % 24, 32, 40, 2, 48);
            print("x", 44, 40);
            printNumI((time_save / 60) % 60, 56, 40, 2, 48);
            print("v", 68, 40);

            print("Dctuj pf&", CENTER, 32);          //строка всего за:

            init_rads_unit(1, rad_dose_save, 10, 5, 1, 8, 1, 62, 16); //строка 1 сохранённая доза
            break;
        }
        break;
    }
  }

#if SEARCH_RETURN
  switch (scr_mode)
  {
    case 2: graf_init(); break; //строим график
  }
#endif

  //+++++++++++++++++++++  опрос кнопок  +++++++++++++++++++++++++++
  switch (check_keys())
  {
    case 1: //Down key hold //сброс
      switch (scr_mode)
      {
        case 0: //сбрасываем максимальный фон и средний фон
#if SEARCH_RETURN
          rad_mid = 0; //сбрасываем среднее значение фона
          rad_max = 0; //сбрасываем максимальное значение фона
          tmr_mid = 0; //сбрасываем счетчик среднего фона
          first_mid = 0; //сбрасываем флаг первого среднего замера фона
          rad_mid_buff = 0; //сбрасываем буфер среднего замера фона
#else
          for (uint8_t i = 0; i < GEIGER_TIME; i++) rad_buff[i] = 0; //очищаем буфер фона
          geiger_time_now = 0; //сбрасываем счетчик накопления импульсов в буфере
          rad_back = 0; //сбрасываем фон

          switch (f) {
            case 0:
              for (uint8_t i = 0; i < 84; i++) graf_buff[i] = 0; //очищаем буфер графика
              rad_scan_buff = 0; //очищаем счетный буфер графика
              break;

            case 1:
              rad_mid = 0; //сбрасываем среднее значение фона
              rad_max = 0; //сбрасываем максимальное значение фона
              tmr_mid = 0; //сбрасываем счетчик среднего фона
              first_mid = 0; //сбрасываем флаг первого среднего замера фона
              rad_mid_buff = 0; //сбрасываем буфер среднего замера фона
              break;
          }
#endif
          break;

        case 1: dose_reset(); break; //сбрасываем дозу и время
#if SEARCH_RETURN
        case 2://сбрасываем счетчик частиц или счетчик импульсов и график
#if TYPE_SERCH_UNIT
          rad_imp = 0;
          for (uint8_t i = 0; i < 84; i++) graf_buff[i] = 0; //очищаем буфер нрафика
          graf_init(); //инициализируем график
#else
          rad_scan = 0;
          for (uint8_t i = 0; i < 84; i++) graf_buff[i] = 0; //очищаем буфер нрафика
          graf_init(); //инициализируем график
#endif
          break;
#endif
      }
      scr = 0; //разрешаем обновления экрана
      break;

    case 2: //Down key //выбор режима
      switch (alarm_switch) {
        case 0: if (scr_mode > 0) scr_mode--; else scr_mode = MAX_SCREENS; break; //назад
        case 3: warn_back_wait = 1; alarm_switch = 0; _vibro_off(); buzz_read(); break; //фон
        case 4: warn_dose_wait = rad_dose; alarm_switch = 0; _vibro_off(); buzz_read(); break; //доза
      }
      scr = 0; //разрешаем обновления экрана
      break;

    case 3: //Up key  //выбор режима
      switch (alarm_switch) {
        case 0: if (scr_mode < MAX_SCREENS) scr_mode++; else scr_mode = 0; break; //вперёд
        case 3: warn_back_wait = 1; alarm_switch = 0; _vibro_off(); buzz_read(); break; //фон
        case 4: warn_dose_wait = rad_dose; alarm_switch = 0; _vibro_off(); buzz_read(); break; //доза
      }
      scr = 0; //разрешаем обновления экрана
      break;

    case 4: //Up key hold //быстрое меню
      if (!alarm_switch) fast_menu(); //быстрое меню
      scr = 0; //разрешаем обновления экрана
      break;

    case 5: //select key // доп.действие
      switch (alarm_switch) {
        case 0:
          switch (scr_mode)
          {
            case 0: //сбрасываем текущий фон
#if SEARCH_RETURN
              for (uint8_t i = 0; i < GEIGER_TIME; i++) rad_buff[i] = 0; //очищаем буфер фона
              geiger_time_now = 0; //сбрасываем счетчик накопления импульсов в буфере
              rad_back = 0; //сбрасываем фон
#else
              switch (f) {
                case 0: f = 1; break;
                case 1: f = 0; break;
              }
#endif
              break;

            case 1://перключение режимов дозы
              if (++dose_mode > 1) dose_mode = 0;
              break;
#if SEARCH_RETURN
            case 2://пауза графика
              if (serch_disable) serch_disable = 0; else serch_disable = 1;
              graf_init();
              break;
#endif
          }
          break;
        case 3: warn_back_wait = 1; alarm_switch = 0; _vibro_off(); buzz_read(); break; //фон
        case 4: warn_dose_wait = rad_dose; alarm_switch = 0; _vibro_off(); buzz_read(); break; //доза
      }
      scr = 0; //разрешаем обновления экрана
      break;

    case 6: //hold select key //меню
      if (!alarm_switch) setings();
      scr = 0; //разрешаем обновления экрана
      break;
  }
}
